create or replace PACKAGE BODY ur_utils IS



Â  Â  PROCEDURE VALIDATE_TEMPLATE_DEFINITION (

Â  Â  Â  Â  p_json_clobÂ  Â INÂ  Â  Â  Â  Â  Â  CLOB,

Â  Â  Â  Â  p_alert_clobÂ  IN OUT NOCOPY CLOB,

Â  Â  Â  Â  p_statusÂ  Â  Â  OUTÂ  Â  Â  Â  Â  Â VARCHAR2

Â  Â  )

Â  Â  IS

Â  Â  Â  Â  l_error_found BOOLEAN := FALSE;

Â  Â  BEGIN

Â  Â  Â  Â  -- Loop through each JSON object in the array where a 'qualifier' exists.

Â  Â  Â  Â  FOR r IN (

Â  Â  Â  Â  Â  Â  SELECT

Â  Â  Â  Â  Â  Â  Â  Â  nm,

Â  Â  Â  Â  Â  Â  Â  Â  dt,

Â  Â  Â  Â  Â  Â  Â  Â  qlf

Â  Â  Â  Â  Â  Â  FROM

Â  Â  Â  Â  Â  Â  Â  Â  JSON_TABLE(p_json_clob, '$[*]'

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  COLUMNS (

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  nmÂ  VARCHAR2(255) PATH '$.name',

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  dtÂ  VARCHAR2(50)Â  PATH '$.data_type',

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  qlf VARCHAR2(255) PATH '$.qualifier'

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  )

Â  Â  Â  Â  Â  Â  Â  Â  )

Â  Â  Â  Â  Â  Â  WHERE

Â  Â  Â  Â  Â  Â  Â  Â  qlf IS NOT NULL

Â  Â  Â  Â  ) LOOP

Â  Â  Â  Â  Â  Â  -- RULE 1: Qualifiers with 'DATE' in the name must have a 'DATE' data_type.

Â  Â  Â  Â  Â  Â  IF INSTR(UPPER(r.qlf), 'DATE') > 0 THEN

Â  Â  Â  Â  Â  Â  Â  Â  IF r.dt <> 'DATE' THEN

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  l_error_found := TRUE;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ur_utils.add_alert(

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  p_alert_clob,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'Field "' || r.nm || '": Qualifier "' || r.qlf || '" must be DATE.',

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'error', NULL, NULL, p_alert_clob);

Â  Â  Â  Â  Â  Â  Â  Â  END IF;

Â  Â  Â  Â  Â  Â  -- RULE 2: All other qualifiers must have a 'NUMBER' data_type.

Â  Â  Â  Â  Â  Â  ELSE

Â  Â  Â  Â  Â  Â  Â  Â  IF r.dt <> 'NUMBER' THEN

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  l_error_found := TRUE;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ur_utils.add_alert(

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  p_alert_clob,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'Field "' || r.nm || '": Qualifier "' || r.qlf || '" must be NUMBER.',

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'error', NULL, NULL, p_alert_clob);

Â  Â  Â  Â  Â  Â  Â  Â  END IF;

Â  Â  Â  Â  Â  Â  END IF;

Â  Â  Â  Â  END LOOP;



Â  Â  Â  Â  -- Set the final status ('S'uccess or 'E'rror) and add a success message if needed.

Â  Â  Â  Â  IF l_error_found THEN

Â  Â  Â  Â  Â  Â  p_status := 'E';

Â  Â  Â  Â  ELSE

Â  Â  Â  Â  Â  Â  p_status := 'S';

Â  Â  Â  Â  Â  Â  ur_utils.add_alert(p_alert_clob, 'Template definition validated successfully.', 'success', NULL, NULL, p_alert_clob);

Â  Â  Â  Â  END IF;



Â  Â  EXCEPTION

Â  Â  Â  Â  WHEN OTHERS THEN

Â  Â  Â  Â  Â  Â  p_status := 'E';

Â  Â  Â  Â  Â  Â  ur_utils.add_alert(p_alert_clob, 'Unexpected validation error: ' || SQLERRM, 'error', NULL, NULL, p_alert_clob);

Â  Â  END VALIDATE_TEMPLATE_DEFINITION;



FUNCTION GET_ATTRIBUTE_VALUE (

Â  Â  p_attribute_idÂ  Â  INÂ  RAWÂ  Â  Â  Â DEFAULT NULL,

Â  Â  p_attribute_keyÂ  Â INÂ  VARCHAR2Â  DEFAULT NULL,

Â  Â  p_hotel_idÂ  Â  Â  Â  INÂ  RAWÂ  Â  Â  Â DEFAULT NULL,

Â  Â  p_stay_dateÂ  Â  Â  Â INÂ  DATEÂ  Â  Â  DEFAULT NULL,

Â  Â  p_round_digitsÂ  Â  INÂ  NUMBERÂ  Â  DEFAULT 2

Â  ) RETURN UR_attribute_value_table PIPELINED AS

Â  Â  l_response_clob CLOB;

Â  Â  l_statusÂ  Â  Â  Â  VARCHAR2(1);

Â  BEGIN

Â  Â  GET_ATTRIBUTE_VALUE(

Â  Â  Â  p_attribute_idÂ  Â  => p_attribute_id,

Â  Â  Â  p_attribute_keyÂ  Â => p_attribute_key,

Â  Â  Â  p_hotel_idÂ  Â  Â  Â  => p_hotel_id,

Â  Â  Â  p_stay_dateÂ  Â  Â  Â => p_stay_date,

Â  Â  Â  p_round_digitsÂ  Â  => p_round_digits,

Â  Â  Â  p_debug_flagÂ  Â  Â  => FALSE,

Â  Â  Â  p_response_clobÂ  Â => l_response_clob

Â  Â  );



Â  Â  l_status := JSON_VALUE(l_response_clob, '$.STATUS');

Â  Â Â 

Â  Â  IF l_status = 'S' THEN

Â  Â  Â  FOR rec IN (

Â  Â  Â  Â  Â  SELECT

Â  Â  Â  Â  Â  Â  Â  TO_DATE(jt.stay_date, 'DD-MON-YYYY') AS stay_date,

Â  Â  Â  Â  Â  Â  Â  jt.attribute_value

Â  Â  Â  Â  Â  FROM

Â  Â  Â  Â  Â  Â  Â  JSON_TABLE(

Â  Â  Â  Â  Â  Â  Â  Â  Â  l_response_clob,

Â  Â  Â  Â  Â  Â  Â  Â  Â  '$.RESPONSE_PAYLOAD[*]'

Â  Â  Â  Â  Â  Â  Â  Â  Â  COLUMNS (

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  stay_dateÂ  Â  Â  Â VARCHAR2(20) PATH '$.stay_date',

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  attribute_value NUMBERÂ  Â  Â  Â PATH '$.attribute_value'

Â  Â  Â  Â  Â  Â  Â  Â  Â  )

Â  Â  Â  Â  Â  Â  Â  ) jt

Â  Â  Â  ) LOOP

Â  Â  Â  Â  Â  PIPE ROW(UR_attribute_value_row(rec.stay_date, rec.attribute_value));

Â  Â  Â  END LOOP;

Â  Â  END IF;

Â  Â  RETURN;

Â  EXCEPTION WHEN OTHERS THEN RETURN;

Â  END GET_ATTRIBUTE_VALUE;





Â  -- =================================================================

Â  --Â  MAIN PROCEDURE IMPLEMENTATION (Returns JSON CLOB)

Â  -- =================================================================

Â  PROCEDURE build_json_response(

Â  Â  Â  p_statusÂ  Â  Â  Â  Â  Â  Â  Â IN VARCHAR2, p_messageÂ  Â  Â  Â  Â  Â  Â  IN CLOB,

Â  Â  Â  p_attribute_idÂ  Â  Â  Â  Â IN RAW,Â  Â  Â  p_attribute_nameÂ  Â  Â  Â IN VARCHAR2,

Â  Â  Â  p_attribute_keyÂ  Â  Â  Â  IN VARCHAR2, p_attribute_datatypeÂ  Â IN VARCHAR2,

Â  Â  Â  p_attribute_qualifierÂ  IN VARCHAR2, p_attribute_static_val IN VARCHAR2,

Â  Â  Â  p_hotel_idÂ  Â  Â  Â  Â  Â  Â IN RAW,Â  Â  Â  p_stay_dateÂ  Â  Â  Â  Â  Â  IN DATE,

Â  Â  Â  p_debug_flagÂ  Â  Â  Â  Â  Â IN BOOLEAN,Â  p_record_countÂ  Â  Â  Â  Â IN NUMBER,

Â  Â  Â  p_payload_arrayÂ  Â  Â  Â  IN JSON_ARRAY_T, p_response_clob OUT CLOB

Â  ) IS l_json_obj JSON_OBJECT_T;

Â  BEGIN

Â  Â  Â  l_json_obj := JSON_OBJECT_T();

Â  Â  Â  l_json_obj.put('attribute_id', RAWTOHEX(p_attribute_id));

Â  Â  Â  l_json_obj.put('attribute_name', p_attribute_name);

Â  Â  Â  l_json_obj.put('attribute_key', p_attribute_key);

Â  Â  Â  l_json_obj.put('attribute_datatype', p_attribute_datatype);

Â  Â  Â  l_json_obj.put('attribute_qualifier', p_attribute_qualifier);

Â  Â  Â  l_json_obj.put('attribute_static_value', p_attribute_static_val);

Â  Â  Â  l_json_obj.put('hotel_id', RAWTOHEX(p_hotel_id));

Â  Â  Â  l_json_obj.put('stay_date', TO_CHAR(p_stay_date, 'YYYY-MM-DD'));

Â  Â  Â  l_json_obj.put('DEBUG_FLAG', CASE WHEN p_debug_flag THEN 'TRUE' ELSE 'FALSE' END);

Â  Â  Â  l_json_obj.put('RESPONSE_TIME', TO_CHAR(SYSTIMESTAMP, 'YYYY-MM-DD"T"HH24:MI:SS.FF"Z"'));

Â  Â  Â  l_json_obj.put('STATUS', p_status); l_json_obj.put('RECORD_COUNT', p_record_count);

Â  Â  Â  l_json_obj.put('MESSAGE', p_message); l_json_obj.put('RESPONSE_PAYLOAD', p_payload_array);

Â  Â  Â  p_response_clob := l_json_obj.to_clob;

Â  EXCEPTION WHEN OTHERS THEN p_response_clob := '{"STATUS":"E", "MESSAGE":"Failed to generate final JSON response: ' || SQLERRM || '"}';

Â  END build_json_response;



Â  PROCEDURE GET_ATTRIBUTE_VALUE (Â  Â 

Â  Â  Â  Â  p_attribute_idÂ  Â  INÂ  RAWÂ  Â  Â  Â DEFAULT NULL,Â 

Â  Â  Â  Â  p_attribute_keyÂ  Â INÂ  VARCHAR2Â  DEFAULT NULL,Â 

Â  Â  Â  Â  p_hotel_idÂ  Â  Â  Â  INÂ  RAWÂ  Â  Â  Â DEFAULT NULL,Â 

Â  Â  Â  Â  p_stay_dateÂ  Â  Â  Â INÂ  DATEÂ  Â  Â  DEFAULT NULL,Â 

Â  Â  Â  Â  p_round_digitsÂ  Â  INÂ  NUMBERÂ  Â  DEFAULT 2,Â 

Â  Â  Â  Â  p_debug_flagÂ  Â  Â  INÂ  BOOLEANÂ  Â DEFAULT FALSE,Â 

Â  Â  Â  Â  p_response_clobÂ  Â OUT CLOB )Â 

Â  Â  ISÂ 

Â  Â  l_attribute_recÂ  Â  Â  Â UR_ALGO_ATTRIBUTES%ROWTYPE;Â 

Â  Â  l_template_recÂ  Â  Â  Â  UR_TEMPLATES%ROWTYPE;Â 

Â  Â  l_sql_stmtÂ  Â  Â  Â  Â  Â  VARCHAR2(8000);Â 

Â  Â  l_cursorÂ  Â  Â  Â  Â  Â  Â  SYS_REFCURSOR;Â 

Â  Â  l_stay_date_valÂ  Â  Â  Â DATE;Â 

Â  Â  l_attribute_val_outÂ  Â VARCHAR2(4000);Â 

Â  Â  l_records_fetchedÂ  Â  Â NUMBER := 0;Â 

Â  Â  l_json_payload_arrÂ  Â  JSON_ARRAY_T := JSON_ARRAY_T();Â 

Â  Â  l_json_row_objÂ  Â  Â  Â  JSON_OBJECT_T;Â 

Â  Â  l_statusÂ  Â  Â  Â  Â  Â  Â  VARCHAR2(1) := 'S';Â 

Â  Â  l_messageÂ  Â  Â  Â  Â  Â  Â CLOB;Â 

Â  Â  l_debug_logÂ  Â  Â  Â  Â  Â CLOB;



Â  Â  Â  PROCEDURE append_debug(p_log_entry IN VARCHAR2) IS BEGIN IF p_debug_flag THEN l_debug_log := l_debug_log || TO_CHAR(SYSTIMESTAMP, 'HH24:MI:SS.FF') || ' - ' || p_log_entry || CHR(10); END IF; END append_debug;

Â  Â  Â  BEGIN

Â  Â  Â  Â  append_debug('Procedure started.');

Â  Â  Â  IF (p_attribute_id IS NULL AND p_attribute_key IS NULL) OR (p_attribute_id IS NOT NULL AND p_attribute_key IS NOT NULL) THEN

Â  Â  Â  Â  Â  l_message := 'Validation Error: Provide either p_attribute_id or p_attribute_key, but not both.';

Â  Â  Â  Â  Â  build_json_response('E', l_message, NULL, NULL, p_attribute_key, NULL, NULL, NULL, p_hotel_id, p_stay_date, p_debug_flag, 0, JSON_ARRAY_T('[]'), p_response_clob); RETURN;

Â  Â  Â  END IF;

Â  Â  Â  BEGIN IF p_attribute_id IS NOT NULL THEN SELECT * INTO l_attribute_rec FROM UR_ALGO_ATTRIBUTES WHERE ID = p_attribute_id; ELSE SELECT * INTO l_attribute_rec FROM UR_ALGO_ATTRIBUTES WHERE KEY = p_attribute_key; END IF; append_debug('Found attribute with ID: ' || RAWTOHEX(l_attribute_rec.ID) || ', TYPE: ' || l_attribute_rec.TYPE || ', VALUE: ' || l_attribute_rec.VALUE);

Â  Â  Â  EXCEPTION WHEN NO_DATA_FOUND THEN l_message := 'Attribute not found for the specified ID or KEY.'; build_json_response('E', l_message, p_attribute_id, NULL, p_attribute_key, NULL, NULL, NULL, p_hotel_id, p_stay_date, p_debug_flag, 0, JSON_ARRAY_T('[]'), p_response_clob); RETURN; END;

Â  Â  Â Â 

Â  IF l_attribute_rec.TYPE = 'M' THEN

Â  Â  Â  append_debug('Attribute type is Manual. Using static value.'); l_json_row_obj := JSON_OBJECT_T(); l_json_row_obj.put('stay_date', TO_CHAR(p_stay_date, 'DD-MON-YYYY'));

Â  Â  Â  CASE UPPER(l_attribute_rec.DATA_TYPE) WHEN 'NUMBER' THEN l_json_row_obj.put('attribute_value', ROUND(TO_NUMBER(l_attribute_rec.VALUE), p_round_digits)); ELSE l_json_row_obj.put('attribute_value', l_attribute_rec.VALUE); END CASE;

Â  Â  Â  l_json_payload_arr.append(l_json_row_obj); l_records_fetched := 1; l_message := 'Manual value returned.';

Â Â 

Â  ELSIF l_attribute_rec.TYPE = 'S' THEN

Â  Â  Â  append_debug('Attribute type is Sourced. Parsing value formula.');

Â  Â  Â  DECLARE

Â  Â  Â  Â  Â  TYPE t_table_map IS TABLE OF VARCHAR2(10) INDEX BY VARCHAR2(150);

Â  Â  Â  Â  Â  l_tablesÂ  Â  Â  Â  Â  Â  Â t_table_map;

Â  Â  Â  Â  Â  l_formulaÂ  Â  Â  Â  Â  Â  VARCHAR2(4000) := l_attribute_rec.VALUE;

Â  Â  Â  Â  Â  l_expressionÂ  Â  Â  Â  Â VARCHAR2(4000) := l_formula;

Â  Â  Â  Â  Â  l_from_clauseÂ  Â  Â  Â  VARCHAR2(4000);

Â  Â  Â  Â  Â  l_where_clauseÂ  Â  Â  Â VARCHAR2(1000) := ' WHERE 1=1';

Â  Â  Â  Â  Â  l_stay_date_columnÂ  Â VARCHAR2(150);

Â  Â  Â  Â  Â  l_base_table_aliasÂ  Â VARCHAR2(10) := 't1';

Â  Â  Â  Â  Â  l_table_counterÂ  Â  Â  NUMBER := 1;

Â  Â  Â  Â  Â  l_posÂ  Â  Â  Â  Â  Â  Â  Â  NUMBER := 1;

Â  Â  Â  Â  Â  l_source_refÂ  Â  Â  Â  Â VARCHAR2(200);

Â  Â  Â  BEGIN

Â  Â  Â  Â  Â  -- ### MODIFICATION: Get STAY_DATE column name with new exception logic ###

Â  Â  Â  Â  Â  IF l_attribute_rec.ATTRIBUTE_QUALIFIER IN ('OWN_PROPERTY', 'COMP_PROPERTY') THEN

Â  Â  Â  Â  Â  Â  Â  append_debug('Attribute qualifier is OWN/COMP_PROPERTY. Using hardcoded STAY_DATE column name.');

Â  Â  Â  Â  Â  Â  Â  l_stay_date_column := 'STAY_DATE';

Â  Â  Â  Â  Â  ELSE

Â  Â  Â  Â  Â  Â  Â  append_debug('Looking up STAY_DATE column from template definition.');

Â  Â  Â  Â  Â  Â  Â  BEGINÂ 

Â  Â  Â  Â  Â  Â  Â  Â  Â  SELECT * INTO l_template_rec FROM UR_TEMPLATES WHERE ID = l_attribute_rec.TEMPLATE_ID;

Â  Â  Â  Â  Â  Â  Â  Â  Â  SELECT jt.name INTO l_stay_date_column FROM JSON_TABLE(l_template_rec.DEFINITION, '$[*]' COLUMNS (name VARCHAR2(100) PATH '$.name', qualifier VARCHAR2(100) PATH '$.qualifier')) jt WHERE jt.qualifier = 'STAY_DATE';

Â  Â  Â  Â  Â  Â  Â  EXCEPTION WHEN NO_DATA_FOUND THEN RAISE_APPLICATION_ERROR(-20004, 'Critical error: Associated template definition requires a ''STAY_DATE'' qualifier for this attribute type.');

Â  Â  Â  Â  Â  Â  Â  END;

Â  Â  Â  Â  Â  END IF;

Â  Â  Â  Â  Â  append_debug('Determined Stay Date column is: ' || l_stay_date_column);



Â  Â  Â  Â  Â  -- 1. Parse all source references and build FROM clause

Â  Â  Â  Â  Â  LOOP

Â  Â  Â  Â  Â  Â  Â  l_source_ref := REGEXP_SUBSTR(l_formula, '#([^#]+)#', l_pos, 1, NULL, 1);

Â  Â  Â  Â  Â  Â  Â  EXIT WHEN l_source_ref IS NULL;

Â  Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  Â  DECLARE

Â  Â  Â  Â  Â  Â  Â  Â  Â  l_table_name VARCHAR2(150) := REGEXP_SUBSTR(l_source_ref, '^[^.]+');

Â  Â  Â  Â  Â  Â  Â  Â  Â  l_col_nameÂ  Â VARCHAR2(150) := REGEXP_SUBSTR(l_source_ref, '[^.]+$');

Â  Â  Â  Â  Â  Â  Â  Â  Â  l_aliasÂ  Â  Â  VARCHAR2(10);

Â  Â  Â  Â  Â  Â  Â  BEGIN

Â  Â  Â  Â  Â  Â  Â  Â  Â  IF NOT l_tables.EXISTS(l_table_name) THEN

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  l_alias := 't' || l_table_counter;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  l_tables(l_table_name) := l_alias;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  IF l_table_counter = 1 THEN

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  l_from_clause := DBMS_ASSERT.ENQUOTE_NAME(l_table_name) || ' ' || l_alias;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ELSE

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  l_from_clause := l_from_clause || ' LEFT JOIN ' || DBMS_ASSERT.ENQUOTE_NAME(l_table_name) || ' ' || l_alias ||

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â ' ON ' || l_base_table_alias || '.' || DBMS_ASSERT.ENQUOTE_NAME(l_stay_date_column) || ' = ' || l_alias || '.' || DBMS_ASSERT.ENQUOTE_NAME(l_stay_date_column);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  END IF;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  l_table_counter := l_table_counter + 1;

Â  Â  Â  Â  Â  Â  Â  Â  Â  ELSE

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  l_alias := l_tables(l_table_name);

Â  Â  Â  Â  Â  Â  Â  Â  Â  END IF;

Â  Â  Â  Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  Â  Â  Â  l_expression := REPLACE(l_expression, '#' || l_source_ref || '#', l_alias || '.' || DBMS_ASSERT.ENQUOTE_NAME(l_col_name));

Â  Â  Â  Â  Â  Â  Â  END;

Â  Â  Â  Â  Â  Â  Â  l_pos := REGEXP_INSTR(l_formula, '#', l_pos, 2) + 1;

Â  Â  Â  Â  Â  END LOOP;



Â  Â  Â  Â  Â  IF l_from_clause IS NULL THEN RAISE_APPLICATION_ERROR(-20001, 'Invalid Sourced Attribute: Formula is missing a source reference like #TABLE.COLUMN#.'); END IF;

Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  -- 2. Validate expression (now includes brackets)

Â  Â  Â  Â  Â  DECLARE l_validation_check VARCHAR2(4000);

Â  Â  Â  Â  Â  BEGIN

Â  Â  Â  Â  Â  Â  Â  l_validation_check := REGEXP_REPLACE(l_expression, '[''a-zA-Z0-9_."''\(\)0-9\.\+\*\/ \t\r\n-]', '');

Â  Â  Â  Â  Â  Â  Â  IF l_validation_check IS NOT NULL THEN RAISE_APPLICATION_ERROR(-20003, 'Invalid Sourced Attribute: Formula contains illegal characters.'); END IF;

Â  Â  Â  Â  Â  END;



Â  Â  Â  Â  Â  -- 4. Build final SQL

Â  Â  Â  Â  Â  IF p_stay_date IS NOT NULL THEN l_where_clause := l_where_clause || ' AND TRUNC(' || l_base_table_alias || '.' || DBMS_ASSERT.ENQUOTE_NAME(l_stay_date_column) || ') = TRUNC(:stay_date)'; END IF;

Â  Â  Â  Â  Â  IF p_hotel_id IS NOT NULL THEN l_where_clause := l_where_clause || ' AND ' || l_base_table_alias || '.' || DBMS_ASSERT.ENQUOTE_NAME('HOTEL_ID') || ' = :hotel_id'; END IF;



Â  Â  Â  Â  Â  l_sql_stmt := 'SELECT ' || l_base_table_alias || '.' || DBMS_ASSERT.ENQUOTE_NAME(l_stay_date_column) ||Â 

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ', ROUND((' || l_expression || '), :round_digits)' ||Â 

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ' FROM ' || l_from_clause || l_where_clause;

Â  Â  Â  Â  Â  append_debug('Dynamic SQL: ' || l_sql_stmt);

Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  CASE WHEN p_stay_date IS NOT NULL AND p_hotel_id IS NOT NULL THEN OPEN l_cursor FOR l_sql_stmt USING p_round_digits, p_stay_date, p_hotel_id;

Â  Â  Â  Â  Â  Â  Â  Â WHEN p_stay_date IS NOT NULL AND p_hotel_id IS NULL THEN OPEN l_cursor FOR l_sql_stmt USING p_round_digits, p_stay_date;

Â  Â  Â  Â  Â  Â  Â  Â WHEN p_stay_date IS NULL AND p_hotel_id IS NOT NULL THEN OPEN l_cursor FOR l_sql_stmt USING p_round_digits, p_hotel_id;

Â  Â  Â  Â  Â  Â  Â  Â ELSE OPEN l_cursor FOR l_sql_stmt USING p_round_digits;

Â  Â  Â  Â  Â  END CASE;



Â  Â  Â  Â  Â  LOOP FETCH l_cursor INTO l_stay_date_val, l_attribute_val_out; EXIT WHEN l_cursor%NOTFOUND; l_records_fetched := l_records_fetched + 1; l_json_row_obj := JSON_OBJECT_T(); l_json_row_obj.put('stay_date', TO_CHAR(l_stay_date_val, 'DD-MON-YYYY')); l_json_row_obj.put('attribute_value', TO_NUMBER(l_attribute_val_out)); l_json_payload_arr.append(l_json_row_obj); END LOOP; CLOSE l_cursor;

Â  Â  Â  END;

Â  ELSE RAISE_APPLICATION_ERROR(-20005, 'Attribute validation error: Unknown TYPE ''' || l_attribute_rec.TYPE || '''. Must be ''M'' (Manual) or ''S'' (Sourced).'); END IF;



Â  IF l_message IS NULL THEN

Â  Â  l_message := l_records_fetched || ' records fetched successfully.';

Â  Â  IF l_records_fetched = 0 AND l_attribute_rec.TYPE != 'M' THEN l_status := 'W'; l_message := 'No records found for the given criteria.'; END IF;

Â  END IF;

Â  IF p_debug_flag THEN l_message := l_message || CHR(10) || '--- DEBUG LOG ---' || CHR(10) || l_debug_log; END IF;

Â Â 

Â  build_json_response(l_status, l_message, l_attribute_rec.ID, l_attribute_rec.NAME, l_attribute_rec.KEY, l_attribute_rec.DATA_TYPE, l_attribute_rec.ATTRIBUTE_QUALIFIER, l_attribute_rec.VALUE, p_hotel_id, p_stay_date, p_debug_flag, l_records_fetched, l_json_payload_arr, p_response_clob);

Â Â 

Â  EXCEPTION WHEN OTHERS THEN IF l_cursor%ISOPEN THEN CLOSE l_cursor; END IF; l_status := 'E'; l_message := 'An unexpected error occurred: ' || SQLERRM; append_debug(l_message); IF p_debug_flag THEN l_message := l_message || CHR(10) || '--- DEBUG LOG ---' || CHR(10) || l_debug_log; END IF; build_json_response('E', l_message, l_attribute_rec.ID, NVL(l_attribute_rec.NAME, 'UNKNOWN'), NVL(l_attribute_rec.KEY, p_attribute_key), NVL(l_attribute_rec.DATA_TYPE, 'UNKNOWN'), NVL(l_attribute_rec.ATTRIBUTE_QUALIFIER, 'UNKNOWN'), NVL(l_attribute_rec.VALUE, 'UNKNOWN'), p_hotel_id, p_stay_date, p_debug_flag, 0, JSON_ARRAY_T('[]'), p_response_clob);

Â  END GET_ATTRIBUTE_VALUE;







FUNCTION Clean_TEXT(p_text IN VARCHAR2) RETURN VARCHAR2 IS

Â  v_clean VARCHAR2(4000);

BEGIN

Â  v_clean := UPPER(

Â  Â  Â  Â  Â  Â  Â  Â SUBSTR(

Â  Â  Â  Â  Â  Â  Â  Â  Â REGEXP_REPLACE(

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â REGEXP_REPLACE(

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â REGEXP_REPLACE(

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â TRIM(p_text),

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â '^[^A-Za-z0-9]+|[^A-Za-z0-9]+$', ''

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â ),

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â '[^A-Za-z0-9]+', '_'

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â ),

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â '_+', '_'

Â  Â  Â  Â  Â  Â  Â  Â  Â ),

Â  Â  Â  Â  Â  Â  Â  Â  Â 1, 110

Â  Â  Â  Â  Â  Â  Â  Â )

Â  Â  Â  Â  Â  Â  Â );

Â  RETURN v_clean;

END Clean_TEXT;



FUNCTION normalize_json (p_json CLOB) RETURN CLOB IS

BEGIN

Â  RETURN REPLACE(REPLACE(p_json, '"data-type"', '"data_type"'), '"DATA-TYPE"', '"data_type"');

END normalize_json;



Â  PROCEDURE get_collection_json(

Â  Â  p_collection_name IN VARCHAR2,

Â  Â  p_json_clob OUT CLOB,

Â  Â  p_status OUT VARCHAR2,

Â  Â  p_message OUT VARCHAR2

Â  ) IS

Â  Â  l_count NUMBER;

Â  BEGIN

Â  Â  SELECT COUNT(*)

Â  Â  Â  INTO l_count

Â  Â  Â  FROM apex_collections

Â  Â  Â WHERE collection_name = p_collection_name;



Â  Â  IF l_count = 0 THEN

Â  Â  Â  p_status := 'E';

Â  Â  Â  p_message := 'Failure: Collection "' || p_collection_name || '" does not exist or is empty';

Â  Â  Â  p_json_clob := NULL;

Â  Â  Â  RETURN;

Â  Â  END IF;



Â  Â  -- Initialize and build JSON output

Â  Â  apex_json.initialize_clob_output;

Â  Â  apex_json.open_array;



Â  Â  FOR rec IN (

Â  Â  Â  SELECT c001, c002, c003

Â  Â  Â  Â  FROM apex_collections

Â  Â  Â  Â WHERE collection_name = p_collection_name

Â  Â  Â  Â ORDER BY seq_id

Â  Â  )

Â  Â  LOOP

Â  Â  Â  apex_json.open_object;

Â  Â  Â  apex_json.write('name', rec.c001);

Â  Â  Â  apex_json.write('data_type', rec.c002);

Â  Â  Â  apex_json.write('qualifier', rec.c003);

Â  Â  Â  apex_json.close_object;

Â  Â  END LOOP;



Â  Â  apex_json.close_array;



Â  Â  p_json_clob := apex_json.get_clob_output;



Â  Â  apex_json.free_output;



Â  Â  p_status := 'S';

Â  Â  p_message := 'JSON generated for collection "' || p_collection_name || '"';



Â  EXCEPTION

Â  Â  WHEN OTHERS THEN

Â  Â  Â  p_status := 'E';

Â  Â  Â  p_message := 'Failure: ' || SQLERRM;

Â  Â  Â  p_json_clob := NULL;

Â  END get_collection_json;







Â PROCEDURE define_db_object(

Â  Â  p_template_key IN VARCHAR2,

Â  Â  p_statusÂ  Â  Â  Â OUT BOOLEAN,

Â  Â  p_messageÂ  Â  Â  OUT VARCHAR2,

Â  Â  p_modeÂ  Â  Â  Â  Â INÂ  VARCHAR2 DEFAULT 'N'Â  -- 'N' = new create, 'U' = update/replace existing

) IS

Â  Â  v_db_object_name VARCHAR2(30);

Â  Â  v_sqlÂ  Â  Â  Â  Â  Â  CLOB;

Â  Â  v_col_defsÂ  Â  Â  Â CLOB := '';

Â  Â  v_unique_defsÂ  Â  CLOB := '';

Â  Â  v_definitionÂ  Â  Â CLOB;

Â  Â  v_existsÂ  Â  Â  Â  Â NUMBER;

Â  Â  v_trigger_nameÂ  Â VARCHAR2(130);

Â  Â  l_col_nameÂ  Â  Â  Â VARCHAR2(100);

BEGIN

Â  Â  -- ðŸ”’ Lock and fetch details

Â  Â  SELECT db_object_name, definition

Â  Â  Â  INTO v_db_object_name, v_definition

Â  Â  Â  FROM ur_templates

Â  Â  Â WHERE key = p_template_key

Â  Â  Â FOR UPDATE;



Â  Â  IF v_definition IS NULL THEN

Â  Â  Â  Â  p_status := FALSE;

Â  Â  Â  Â  p_message := 'Failure: Definition JSON is NULL for template_key ' || p_template_key;

Â  Â  Â  Â  RETURN;

Â  Â  END IF;



Â  Â  -- Generate table name if not already defined

Â  Â  IF v_db_object_name IS NULL THEN

Â  Â  Â  Â  v_db_object_name := 'UR_' || UPPER(p_template_key) || '_T';

Â  Â  END IF;



Â  Â  -- ðŸ” Check if table exists

Â  Â  SELECT COUNT(*)

Â  Â  Â  INTO v_exists

Â  Â  Â  FROM all_tables

Â  Â  Â WHERE table_name = UPPER(v_db_object_name);



Â  Â  -- ðŸ§© Handle based on mode

Â  Â  IF v_exists > 0 THEN

Â  Â  Â  Â  IF p_mode = 'N' THEN

Â  Â  Â  Â  Â  Â  p_statusÂ  := FALSE;

Â  Â  Â  Â  Â  Â  p_message := 'Failure: Table ' || v_db_object_name || ' already exists.';

Â  Â  Â  Â  Â  Â  RETURN;

Â  Â  Â  Â  ELSIF p_mode = 'U' THEN

Â  Â  Â  Â  Â  Â  -- Drop existing trigger if exists

Â  Â  Â  Â  Â  Â  BEGIN

Â  Â  Â  Â  Â  Â  Â  Â  v_trigger_name := v_db_object_name || '_BI_TRG';

Â  Â  Â  Â  Â  Â  Â  Â  EXECUTE IMMEDIATE 'DROP TRIGGER "' || v_trigger_name || '"';

Â  Â  Â  Â  Â  Â  EXCEPTION

Â  Â  Â  Â  Â  Â  Â  Â  WHEN OTHERS THEN NULL; -- ignore if not exists

Â  Â  Â  Â  Â  Â  END;



Â  Â  Â  Â  Â  Â  -- Drop existing table

Â  Â  Â  Â  Â  Â  BEGIN

Â  Â  Â  Â  Â  Â  Â  Â  EXECUTE IMMEDIATE 'DROP TABLE "' || v_db_object_name || '" CASCADE CONSTRAINTS';

Â  Â  Â  Â  Â  Â  EXCEPTION

Â  Â  Â  Â  Â  Â  Â  Â  WHEN OTHERS THEN

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  p_status := FALSE;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  p_message := 'Failure dropping existing table: ' || SQLERRM;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  RETURN;

Â  Â  Â  Â  Â  Â  END;

Â  Â  Â  Â  END IF;

Â  Â  END IF;



Â  Â  -- Start with ID RAW(16) as primary key column

Â  Â  v_col_defs := '"REC_ID" RAW(16)';



Â  Â  -- Parse JSON definition

Â  Â  FOR rec IN (

Â  Â  Â  Â  SELECT jt.name, jt.data_type, jt.qualifier

Â  Â  Â  Â  FROM JSON_TABLE(

Â  Â  Â  Â  Â  Â  Â  Â  Â normalize_json(v_definition),

Â  Â  Â  Â  Â  Â  Â  Â  Â '$[*]' COLUMNS (

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â nameÂ  Â  Â  VARCHAR2(100) PATH '$.name',

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â data_type VARCHAR2(30)Â  PATH '$.data_type',

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â qualifier VARCHAR2(30)Â  PATH '$.qualifier'

Â  Â  Â  Â  Â  Â  Â  Â  Â )

Â  Â  Â  Â  Â  Â  Â ) jt

Â  Â  ) LOOP

Â  Â  Â  Â  -- Sanitize and normalize column name

Â  Â  Â  Â  l_col_name := UPPER(TRIM(BOTH '_' FROM rec.name));

Â  Â  Â  Â  l_col_name := REGEXP_REPLACE(l_col_name, '_{2,}', '_');

Â  Â  Â  Â  v_col_defs := v_col_defs || ', ';



Â  Â  Â  Â  -- Map data types

Â  Â  Â  Â  IF UPPER(rec.data_type) = 'TEXT' THEN

Â  Â  Â  Â  Â  Â  v_col_defs := v_col_defs || '"' || l_col_name || '" VARCHAR2(4000)';

Â  Â  Â  Â  ELSIF UPPER(rec.data_type) = 'NUMBER' THEN

Â  Â  Â  Â  Â  Â  v_col_defs := v_col_defs || '"' || l_col_name || '" NUMBER';

Â  Â  Â  Â  ELSIF UPPER(rec.data_type) = 'DATE' THEN

Â  Â  Â  Â  Â  Â  v_col_defs := v_col_defs || '"' || l_col_name || '" DATE';

Â  Â  Â  Â  ELSE

Â  Â  Â  Â  Â  Â  v_col_defs := v_col_defs || '"' || l_col_name || '" VARCHAR2(4000)';

Â  Â  Â  Â  END IF;



Â  Â  Â  Â  -- Add unique constraint for special qualifiers

Â  Â  Â  Â  IF UPPER(rec.qualifier) = 'STAY_DATE' THEN

Â  Â  Â  Â  Â  Â  v_unique_defs :=

Â  Â  Â  Â  Â  Â  Â  Â  v_unique_defs ||

Â  Â  Â  Â  Â  Â  Â  Â  ', CONSTRAINT "' || v_db_object_name || '_' || l_col_name || '_UQ" UNIQUE ("' ||

Â  Â  Â  Â  Â  Â  Â  Â  l_col_name || '")';

Â  Â  Â  Â  END IF;

Â  Â  END LOOP;



Â  Â  -- Add WHO / AUDIT columns

Â  Â  v_col_defs :=

Â  Â  Â  Â  v_col_defs ||

Â  Â  Â  Â  ', CREATED_BY RAW(16), UPDATED_BY RAW(16), CREATED_ON DATE, UPDATED_ON DATE, HOTEL_ID RAW(16), INTERFACE_LOG_ID RAW(16)';



Â  Â  -- Build CREATE TABLE DDL

Â  Â  v_sql :=

Â  Â  Â  Â  'CREATE TABLE "' || v_db_object_name || '" (' ||

Â  Â  Â  Â  v_col_defs ||

Â  Â  Â  Â  ', CONSTRAINT "' || v_db_object_name || '_PK" PRIMARY KEY ("REC_ID")' ||

Â  Â  Â  Â  v_unique_defs || ')';



Â  Â  EXECUTE IMMEDIATE v_sql;



Â  Â  -- Create or replace trigger

Â  Â  v_trigger_name := v_db_object_name || '_BI_TRG';

Â  Â  v_sql := '

CREATE OR REPLACE EDITIONABLE TRIGGER "' || v_trigger_name || '"

BEFORE INSERT OR UPDATE ON "' || v_db_object_name || '"

FOR EACH ROW

DECLARE

Â  v_user_id UR_USERS.USER_ID%TYPE;

BEGIN

Â  SELECT USER_ID INTO v_user_id

Â  Â  FROM UR_USERS

Â  Â WHERE USER_NAME = SYS_CONTEXT(''APEX$SESSION'', ''APP_USER'');



Â  IF :NEW.REC_ID IS NULL THEN

Â  Â  :NEW.REC_ID := SYS_GUID();

Â  END IF;



Â  IF INSERTING THEN

Â  Â  :NEW.CREATED_BY := v_user_id;

Â  Â  :NEW.CREATED_ON := SYSDATE;

Â  Â  :NEW.UPDATED_BY := v_user_id;

Â  Â  :NEW.UPDATED_ON := SYSDATE;

Â  ELSIF UPDATING THEN

Â  Â  :NEW.UPDATED_BY := v_user_id;

Â  Â  :NEW.UPDATED_ON := SYSDATE;

Â  END IF;

END ' || v_trigger_name || ';

';

Â  Â  EXECUTE IMMEDIATE v_sql;



Â  Â  -- Update UR_TEMPLATES

Â  Â  UPDATE ur_templates

Â  Â  Â  Â SET db_object_nameÂ  Â  Â  Â = v_db_object_name,

Â  Â  Â  Â  Â  Â db_object_created_on = SYSDATE

Â  Â  Â WHERE key = p_template_key;



Â  Â  COMMIT;



Â  Â  p_statusÂ  := TRUE;

Â  Â  IF p_mode = 'U' THEN

Â  Â  Â  Â  p_message := 'Success: Table "' || v_db_object_name || '" redefined (replaced) successfully.';

Â  Â  ELSE

Â  Â  Â  Â  p_message := 'Success: Table "' || v_db_object_name || '" created with ID primary key and trigger.';

Â  Â  END IF;



EXCEPTION

Â  Â  WHEN NO_DATA_FOUND THEN

Â  Â  Â  Â  p_status := FALSE;

Â  Â  Â  Â  p_message := 'Failure: Template key not found';

Â  Â  WHEN OTHERS THEN

Â  Â  Â  Â  p_status := FALSE;

Â  Â  Â  Â  p_message := 'Failure: ' || SQLERRM;

END define_db_object;





PROCEDURE create_ranking_view(

Â  Â  p_template_key IN VARCHAR2,

Â  Â  p_status OUT BOOLEAN,

Â  Â  p_message OUT VARCHAR2

) IS

Â  Â  -- Metadata Variables

Â  Â  v_definitionÂ  Â  Â  Â  CLOB;

Â  Â  v_data_table_nameÂ  Â VARCHAR2(128);

Â  Â  v_view_nameÂ  Â  Â  Â  Â VARCHAR2(128);

Â  Â  v_sdate_colÂ  Â  Â  Â  Â VARCHAR2(128);

Â  Â  v_own_property_colÂ  VARCHAR2(128);

Â  Â  v_property_listÂ  Â  Â CLOB;



Â  Â  -- Dynamic SQL Variables

Â  Â  v_sqlÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â CLOB;

Â  Â  v_pivot_clauseÂ  Â  Â  Â  Â  CLOB; -- For inside the subquery

Â  Â  v_final_columnsÂ  Â  Â  Â  Â CLOB; -- For the final SELECT list

Â  Â  v_property_countÂ  Â  Â  Â  NUMBER := 0;

Â  Â  v_existsÂ  Â  Â  Â  Â  Â  Â  Â  NUMBER;



BEGIN

Â  Â  -- Step 1: Lock row and get metadata

Â  Â  SELECT definition, db_object_name

Â  Â  INTO v_definition, v_data_table_name

Â  Â  FROM ur_templates

Â  Â  WHERE key = p_template_key

Â  Â  FOR UPDATE;



Â  Â  -- Step 2: Validation checks

Â  Â  IF v_definition IS NULL THEN p_status := FALSE; p_message := 'Failure: Definition JSON is NULL.'; ROLLBACK; RETURN; END IF;

Â  Â  IF v_data_table_name IS NULL THEN p_status := FALSE; p_message := 'Failure: DB object not yet defined.'; ROLLBACK; RETURN; END IF;

Â  Â  SELECT COUNT(*) INTO v_exists FROM user_tables WHERE table_name = UPPER(v_data_table_name);

Â  Â  IF v_exists = 0 THEN p_status := FALSE; p_message := 'Failure: Source table ' || v_data_table_name || ' does not exist.'; ROLLBACK; RETURN; END IF;



Â  Â  -- Step 3: Parse JSON to get column names and count all properties

Â  Â  SELECT jt.name INTO v_sdate_col

Â  Â  FROM JSON_TABLE(v_definition, '$[*]' COLUMNS (name VARCHAR2(128) PATH '$.name', qualifier VARCHAR2(128) PATH '$.qualifier')) jt

Â  Â  WHERE jt.qualifier = 'STAY_DATE';



Â  Â  SELECT jt.name INTO v_own_property_col

Â  Â  FROM JSON_TABLE(v_definition, '$[*]' COLUMNS (name VARCHAR2(128) PATH '$.name', qualifier VARCHAR2(128) PATH '$.qualifier')) jt

Â  Â  WHERE jt.qualifier = 'OWN_PROPERTY';



Â  Â  SELECT LISTAGG('"' || jt.name || '"', ', ') WITHIN GROUP (ORDER BY jt.name), COUNT(jt.name)

Â  Â  INTO v_property_list, v_property_count

Â  Â  FROM JSON_TABLE(v_definition, '$[*]' COLUMNS (name VARCHAR2(128) PATH '$.name', qualifier VARCHAR2(128) PATH '$.qualifier')) jt

Â  Â  WHERE jt.qualifier IN ('OWN_PROPERTY', 'COMP_PROPERTY');



Â  Â  -- Step 4: Build the dynamic PIVOT and final column list clauses

Â  Â  FOR i IN 1..v_property_count LOOP

Â  Â  Â  Â  v_pivot_clause := v_pivot_clause ||

Â  Â  Â  Â  Â  Â  'MAX(CASE WHEN overall_rank = ' || i || ' THEN hotel_name END) AS "RANK_' || i || '_NAME",' || CHR(10) ||

Â  Â  Â  Â  Â  Â  'MAX(CASE WHEN overall_rank = ' || i || ' THEN price END) AS "RANK_' || i || '_RATE",' || CHR(10);

Â  Â  Â  Â Â 

Â  Â  Â  Â  v_final_columns := v_final_columns ||

Â  Â  Â  Â  Â  Â  'p."RANK_' || i || '_NAME",' || CHR(10) ||

Â  Â  Â  Â  Â  Â  'p."RANK_' || i || '_RATE",' || CHR(10);

Â  Â  END LOOP;

Â  Â  v_pivot_clause := RTRIM(v_pivot_clause, ',' || CHR(10));

Â  Â  v_final_columns := RTRIM(v_final_columns, ',' || CHR(10));





Â  Â  -- Step 5: Build the final CREATE VIEW statement

Â  Â  v_view_name := 'UR_' || p_template_key || '_RANKING_V';

Â  Â Â 

Â  Â  v_sql := 'CREATE OR REPLACE VIEW "' || v_view_name || '" AS ' || CHR(10) ||

Â  Â  'WITH all_properties_ranked AS (' || CHR(10) ||

Â  Â  'Â  Â  SELECT ' || CHR(10) ||

Â  Â  'Â  Â  Â  Â  "' || v_sdate_col || '",' || CHR(10) ||

Â  Â  'Â  Â  Â  Â  hotel_name,' || CHR(10) ||

Â  Â  'Â  Â  Â  Â  CASE WHEN REGEXP_LIKE(price, ''^[0-9,.]+$'') THEN TO_NUMBER(REPLACE(price, '','', '''')) ELSE NULL END AS price,' || CHR(10) ||

Â  Â  'Â  Â  Â  Â  ROW_NUMBER() OVER(PARTITION BY "' || v_sdate_col || '" ORDER BY CASE WHEN REGEXP_LIKE(price, ''^[0-9,.]+$'') THEN TO_NUMBER(REPLACE(price, '','', '''')) ELSE NULL END ASC NULLS LAST) as overall_rank' || CHR(10) ||

Â  Â  'Â  Â  FROM "' || v_data_table_name || '"' || CHR(10) ||

Â  Â  'Â  Â  UNPIVOT (price FOR hotel_name IN (' || v_property_list || '))' || CHR(10) ||

Â  Â  ')' || CHR(10) ||

Â  Â  'SELECT ' || CHR(10) ||

Â  Â  'Â  Â  p."' || v_sdate_col || '" AS "STAY_DATE",' || CHR(10) ||

Â  Â  'Â  Â  own.price AS "OWN_PROPERTY_RATE",' || CHR(10) ||

Â  Â  'Â  Â  own.overall_rank AS "OWN_PROPERTY_RANK",' || CHR(10) ||

Â  Â  'Â  Â  ' || v_final_columns || CHR(10) ||

Â  Â  'FROM (' || CHR(10) ||

Â  Â  'Â  Â  SELECT "' || v_sdate_col || '", ' || v_pivot_clause || ' FROM all_properties_ranked GROUP BY "' || v_sdate_col || '"' || CHR(10) ||

Â  Â  ') p' || CHR(10) ||

Â  Â  'JOIN (' || CHR(10) ||

Â  Â  'Â  Â  SELECT "' || v_sdate_col || '", price, overall_rank FROM all_properties_ranked WHERE hotel_name = ''' || v_own_property_col || '''' || CHR(10) ||

Â  Â  ') own ON p."' || v_sdate_col || '" = own."' || v_sdate_col || '"';



Â  Â  -- Step 6: Execute the dynamic SQL

Â  Â  EXECUTE IMMEDIATE v_sql;



Â  Â  Â  Â  -- Update UR_TEMPLATES with the new db_view_object_name and timestamp

Â  Â  UPDATE ur_templates

Â  Â  SET db_view_object_name = v_view_name,

Â  Â  Â  Â  db_view_object_created_on = SYSDATE

Â  Â  WHERE key = p_template_key;



Â  Â  COMMIT;

Â  Â  p_status := TRUE;

Â  Â  p_message := 'Success! Ranking view "' || v_view_name || '" created or replaced.';



EXCEPTION

Â  Â  WHEN NO_DATA_FOUND THEN

Â  Â  Â  Â  p_status := FALSE; p_message := 'Failure: Could not find a required qualifier (STAY_DATE, OWN_PROPERTY) in template key ''' || p_template_key || '''.'; ROLLBACK;

Â  Â  WHEN OTHERS THEN

Â  Â  Â  Â  p_status := FALSE; p_message := 'Failure: ' || SQLERRM;

Â  Â  Â  Â  DBMS_OUTPUT.PUT_LINE('--- FAILED SQL ---'); DBMS_OUTPUT.PUT_LINE(v_sql); DBMS_OUTPUT.PUT_LINE('------------------');

Â  Â  Â  Â  ROLLBACK;

END create_ranking_view;







PROCEDURE LOAD_DATA_MAPPING_COLLECTION (

Â  Â  p_file_idÂ  Â  Â  Â  Â INÂ  VARCHAR2,

Â  Â  p_template_idÂ  Â  INÂ  VARCHAR2,

Â  Â  p_collection_name INÂ  VARCHAR2,

Â  Â  p_statusÂ  Â  Â  Â  Â  OUT VARCHAR2,

Â  Â  p_messageÂ  Â  Â  Â  Â OUT VARCHAR2

) IS



Â  Â  -- Local variables

Â  Â  v_seq_id NUMBER;



BEGIN

Â  Â  -- Initialize outputs

Â  Â  p_status := 'S';

Â  Â  p_message := 'Processing completed successfully.';



Â  Â  ------------------------------------------------------------------------

Â  Â  -- Step 1: Create or truncate the APEX collection

Â  Â  ------------------------------------------------------------------------

Â  Â  BEGIN

Â  Â  Â  Â  IF APEX_COLLECTION.COLLECTION_EXISTS(p_collection_name) THEN

Â  Â  Â  Â  Â  Â  APEX_COLLECTION.DELETE_COLLECTION(p_collection_name);

Â  Â  Â  Â  END IF;



Â  Â  Â  Â  APEX_COLLECTION.CREATE_COLLECTION(p_collection_name);



Â  Â  EXCEPTION

Â  Â  Â  Â  WHEN OTHERS THEN

Â  Â  Â  Â  Â  Â  p_status := 'E';

Â  Â  Â  Â  Â  Â  p_message := 'Failed to create or truncate collection "' || p_collection_name || '": ' || SQLERRM;

Â  Â  Â  Â  Â  Â  RETURN;

Â  Â  END;



Â  Â  ------------------------------------------------------------------------

Â  Â  -- Step 2: Insert data from TEMP_BLOB JSON into collection (c001)

Â  Â  ------------------------------------------------------------------------

Â  Â  BEGIN

Â  Â  Â  Â  FOR rec IN (

Â  Â  Â  Â  Â  Â  SELECT jt.name || ' (' || jt.data_type || ')' AS column_desc, jt.col_position

Â  Â  Â  Â  Â  Â  FROM TEMP_BLOB t,

Â  Â  Â  Â  Â  Â  Â  Â  Â JSON_TABLE(

Â  Â  normalize_json(t.columns),

Â  Â  '$[*]' COLUMNS (

Â  Â  Â  Â nameÂ  Â  Â  VARCHAR2(100) PATH '$.name',

Â  Â  Â  Â data_type VARCHAR2(100) PATH '$.data_type',

Â  Â  Â  Â col_position VARCHAR2(100) PATH '$.pos'

Â  Â  )



Â  Â  Â  Â  Â  Â  Â  Â  Â ) jt

Â  Â  Â  Â  Â  Â  WHERE t.id = p_file_id

Â  Â  Â  Â  ) LOOP

Â  Â  Â  Â  Â  Â  APEX_COLLECTION.ADD_MEMBER(

Â  Â  Â  Â  Â  Â  Â  Â  p_collection_name => p_collection_name,

Â  Â  Â  Â  Â  Â  Â  Â  p_c001Â  Â  Â  Â  Â  Â  => rec.column_desc,

Â  Â  Â  Â  Â  Â  Â  Â  p_c004Â  Â  Â  Â  Â  Â  => rec.col_position

Â  Â  Â  Â  Â  Â  );

Â  Â  Â  Â  END LOOP;



Â  Â  EXCEPTION

Â  Â  Â  Â  WHEN OTHERS THEN

Â  Â  Â  Â  Â  Â  p_status := 'E';

Â  Â  Â  Â  Â  Â  p_message := 'Failed to insert data from TEMP_BLOB (File ID: ' || p_file_id || '): ' || SQLERRM;

Â  Â  Â  Â  Â  Â  RETURN;

Â  Â  END;



Â  Â  ------------------------------------------------------------------------

Â  Â  -- Step 3: Update existing collection members with matching data from UR_TEMPLATES (c002, c003)

Â  Â  ------------------------------------------------------------------------

Â  Â  BEGIN

Â  Â  Â  Â  FOR rec IN (

Â  Â  Â  Â  Â  Â  SELECT jt.name || ' (' || jt.data_type || ')' AS column_desc

Â  Â  Â  Â  Â  Â  FROM UR_TEMPLATES t,

Â  Â  Â  Â  Â  Â  Â  Â  Â JSON_TABLE(

Â  Â  normalize_json(t.definition),

Â  Â  '$[*]' COLUMNS (

Â  Â  Â  Â nameÂ  Â  Â  VARCHAR2(100) PATH '$.name',

Â  Â  Â  Â data_type VARCHAR2(100) PATH '$.data_type'

Â  Â  )

)

Â jt

Â  Â  Â  Â  Â  Â  WHERE t.id = p_template_id

Â  Â  Â  Â  Â  Â  ORDER BY t.id DESC

Â  Â  Â  Â  ) LOOP

Â  Â  Â  Â  Â  Â  BEGIN

Â  Â  Â  Â  Â  Â  Â  Â  -- Find the seq_id for matching collection member

Â  Â  Â  Â  Â  Â  Â  Â  SELECT seq_idÂ 

Â  Â  Â  Â  Â  Â  Â  Â  INTO v_seq_id

Â  Â  Â  Â  Â  Â  Â  Â  FROM apex_collections

Â  Â  Â  Â  Â  Â  Â  Â  WHERE collection_name = p_collection_name

Â  Â  Â  Â  Â  Â  Â  Â  Â  AND c001 = rec.column_desc;



Â  Â  Â  Â  Â  Â  Â  Â  -- Update c002 and c003 attributes

Â  Â  Â  Â  Â  Â  Â  Â  APEX_COLLECTION.UPDATE_MEMBER_ATTRIBUTE(

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  p_collection_name => p_collection_name,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  p_seqÂ  Â  Â  Â  Â  Â  Â => v_seq_id,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  p_attr_numberÂ  Â  Â => 2,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  p_attr_valueÂ  Â  Â  => rec.column_desc

Â  Â  Â  Â  Â  Â  Â  Â  );



Â  Â  Â  Â  Â  Â  Â  Â  APEX_COLLECTION.UPDATE_MEMBER_ATTRIBUTE(

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  p_collection_name => p_collection_name,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  p_seqÂ  Â  Â  Â  Â  Â  Â => v_seq_id,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  p_attr_numberÂ  Â  Â => 3,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  p_attr_valueÂ  Â  Â  => 'Maps To'

Â  Â  Â  Â  Â  Â  Â  Â  );



Â  Â  Â  Â  Â  Â  Â  Â  APEX_COLLECTION.UPDATE_MEMBER_ATTRIBUTE(

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  p_collection_name => p_collection_name,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  p_seqÂ  Â  Â  Â  Â  Â  Â => v_seq_id,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  p_attr_numberÂ  Â  Â => 4,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  p_attr_valueÂ  Â  Â  => NULL

Â  Â  Â  Â  Â  Â  Â  Â  );



Â  Â  Â  Â  Â  Â  EXCEPTION

Â  Â  Â  Â  Â  Â  Â  Â  WHEN NO_DATA_FOUND THEN

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  -- No matching collection member found â€” ignore gracefully

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  NULL;

Â  Â  Â  Â  Â  Â  Â  Â  WHEN OTHERS THEN

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  p_status := 'E';

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  p_message := 'Failed to update member attribute in collection "' || p_collection_name || '" for "'Â 

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â || rec.column_desc || '": ' || SQLERRM;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  RETURN;

Â  Â  Â  Â  Â  Â  END;

Â  Â  Â  Â  END LOOP;



Â  Â  EXCEPTION

Â  Â  Â  Â  WHEN OTHERS THEN

Â  Â  Â  Â  Â  Â  p_status := 'E';

Â  Â  Â  Â  Â  Â  p_message := 'Failed to update collection members from UR_TEMPLATES (ID: ' || p_template_id || '): ' || SQLERRM;

Â  Â  Â  Â  Â  Â  RETURN;

Â  Â  END;



EXCEPTION

Â  Â  WHEN OTHERS THEN

Â  Â  Â  Â  p_status := 'E';

Â  Â  Â  Â  p_message := 'Unexpected error occurred: ' || SQLERRM;

END LOAD_DATA_MAPPING_COLLECTION;



PROCEDURE Load_Data (

Â  Â  p_file_idÂ  Â  Â  Â  Â INÂ  NUMBER,

Â  Â  p_template_keyÂ  Â  INÂ  VARCHAR2,

Â  Â  p_hotel_idÂ  Â  Â  Â  INÂ  RAW,

Â  Â  p_collection_name INÂ  VARCHAR2,

Â  Â  p_statusÂ  Â  Â  Â  Â  OUT BOOLEAN,

Â  Â  p_messageÂ  Â  Â  Â  Â OUT VARCHAR2

) IS

Â  Â  -------------------------------------------------------------------

Â  Â  -- Variables

Â  Â  -------------------------------------------------------------------

Â  Â  l_blobÂ  Â  Â  Â  Â  BLOB;

Â  Â  l_file_nameÂ  Â  Â VARCHAR2(255);

Â  Â  l_table_nameÂ  Â  VARCHAR2(255);

Â  Â  l_template_idÂ  Â RAW(16);

Â  Â  l_total_rowsÂ  Â  NUMBER := 0;

Â  Â  l_success_cntÂ  Â NUMBER := 0;

Â  Â  l_fail_cntÂ  Â  Â  NUMBER := 0;

Â  Â  l_log_idÂ  Â  Â  Â  RAW(16);

Â  Â  l_error_jsonÂ  Â  CLOB := '[';

Â  Â  l_apex_userÂ  Â  Â VARCHAR2(255) := NVL(v('APP_USER'),'APEX_USER');

Â  Â  l_sqlÂ  Â  Â  Â  Â  Â CLOB;



Â  Â  -- Dynamic headers

Â  Â  TYPE t_headers IS TABLE OF VARCHAR2(4000) INDEX BY PLS_INTEGER;

Â  Â  v_headersÂ  Â  Â  t_headers;

Â  Â  v_col_countÂ  Â  PLS_INTEGER := 0;



Â  Â  -- JSON / dynamic variables

Â  Â  v_profile_clob CLOB;

Â  Â  v_sql_jsonÂ  Â  Â CLOB;

Â  Â  cÂ  Â  Â  Â  Â  Â  Â  SYS_REFCURSOR;

Â  Â  v_row_jsonÂ  Â  Â CLOB;

Â  Â  v_line_numberÂ  NUMBER;



Â  Â  -- Row processing

Â  Â  l_colsÂ  Â  Â  Â  Â VARCHAR2(32767);

Â  Â  l_valsÂ  Â  Â  Â  Â VARCHAR2(32767);

Â  Â  l_setÂ  Â  Â  Â  Â  VARCHAR2(32767);

Â  Â  l_stay_col_name VARCHAR2(200);

Â  Â  l_stay_valÂ  Â  Â VARCHAR2(4000);



BEGIN

Â  Â  INSERT INTO debug_log(message) VALUES ('START Load_Data - file_id=' || p_file_id);



Â  Â  -------------------------------------------------------------------

Â  Â  -- 0. Check for duplicate upload

Â  Â  -------------------------------------------------------------------

Â  Â  SELECT COUNT(*)

Â  Â  Â  INTO l_total_rows

Â  Â  Â  FROM ur_interface_logs

Â  Â  Â WHERE file_id = p_file_id

Â  Â  Â  Â AND load_status = 'SUCCESS';



Â  Â  IF l_total_rows > 0 THEN

Â  Â  Â  Â  p_statusÂ  := FALSE;

Â  Â  Â  Â  p_message := 'Failure: File is already uploaded successfully.';

Â  Â  Â  Â  INSERT INTO debug_log(message) VALUES(p_message);

Â  Â  Â  Â  RETURN;

Â  Â  END IF;



Â  Â  -------------------------------------------------------------------

Â  Â  -- 1. Get blob and file name

Â  Â  -------------------------------------------------------------------

Â  Â  SELECT blob_content, filename

Â  Â  Â  INTO l_blob, l_file_name

Â  Â  Â  FROM temp_blob

Â  Â  Â WHERE id = p_file_id;



Â  Â  INSERT INTO debug_log(message) VALUES('Got blob and filename: ' || NVL(l_file_name,'<null>'));



Â  Â  -------------------------------------------------------------------

Â  Â  -- 2. Get target table name + template id

Â  Â  -------------------------------------------------------------------

Â  Â  SELECT db_object_name, id

Â  Â  Â  INTO l_table_name, l_template_id

Â  Â  Â  FROM ur_templates

Â  Â  Â WHERE upper(id) = upper(p_template_key);



Â  Â  INSERT INTO debug_log(message) VALUES('Target table: ' || l_table_name || ', template_id: ' || RAWTOHEX(l_template_id));



Â  Â  -------------------------------------------------------------------

Â  Â  -- 3. Get STAY_DATE column name from template definition (if any)

Â  Â  -------------------------------------------------------------------

Â  Â  BEGIN

Â  Â  Â  Â  SELECT jt.name

Â  Â  Â  Â  Â  INTO l_stay_col_name

Â  Â  Â  Â  Â  FROM ur_templates t,

Â  Â  Â  Â  Â  Â  Â  Â JSON_TABLE(

Â  Â  Â  Â  Â  Â  Â  Â  Â t.definition,

Â  Â  Â  Â  Â  Â  Â  Â  Â '$[*]'

Â  Â  Â  Â  Â  Â  Â  Â  Â COLUMNS (

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â nameÂ  Â  Â  Â VARCHAR2(200) PATH '$.name',

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â qualifierÂ  VARCHAR2(200) PATH '$.qualifier'

Â  Â  Â  Â  Â  Â  Â  Â  Â )

Â  Â  Â  Â  Â  Â  Â  Â ) jt

Â  Â  Â  Â  Â WHERE t.id = l_template_id

Â  Â  Â  Â  Â  Â AND UPPER(jt.qualifier) = 'STAY_DATE'

Â  Â  Â  Â  Â FETCH FIRST 1 ROWS ONLY;

Â  Â  Â  Â  INSERT INTO debug_log(message) VALUES('Found STAY_DATE column in template: ' || l_stay_col_name);

Â  Â  EXCEPTION

Â  Â  Â  Â  WHEN NO_DATA_FOUND THEN

Â  Â  Â  Â  Â  Â  l_stay_col_name := NULL;

Â  Â  Â  Â  Â  Â  INSERT INTO debug_log(message) VALUES('No STAY_DATE configured in template');

Â  Â  END;



Â  Â  -------------------------------------------------------------------

Â  Â  -- 4. Discover file profile

Â  Â  -------------------------------------------------------------------

Â  Â  v_profile_clob := apex_data_parser.discover(

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â p_contentÂ  Â => l_blob,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â p_file_name => l_file_name

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  );



Â  Â  INSERT INTO debug_log(message) VALUES('apex_data_parser.discover done');



Â  Â  -------------------------------------------------------------------

Â  Â  -- 5. Insert initial log row

Â  Â  -------------------------------------------------------------------

Â  Â  l_log_id := sys_guid();

Â  Â  INSERT INTO ur_interface_logs (

Â  Â  Â  Â  id, hotel_id, template_id, interface_type,

Â  Â  Â  Â  load_start_time, load_status, created_by, updated_by,

Â  Â  Â  Â  created_on, updated_on, file_id

Â  Â  )

Â  Â  VALUES (

Â  Â  Â  Â  l_log_id,

Â  Â  Â  Â  p_hotel_id,

Â  Â  Â  Â  l_template_id,

Â  Â  Â  Â  'UPLOAD',

Â  Â  Â  Â  systimestamp,

Â  Â  Â  Â  'IN_PROGRESS',

Â  Â  Â  Â  hextoraw(rawtohex(utl_raw.cast_to_raw(l_apex_user))),

Â  Â  Â  Â  hextoraw(rawtohex(utl_raw.cast_to_raw(l_apex_user))),

Â  Â  Â  Â  sysdate, sysdate,

Â  Â  Â  Â  p_file_id

Â  Â  );



Â  Â  INSERT INTO debug_log(message) VALUES('Inserted ur_interface_logs id=' || RAWTOHEX(l_log_id));



Â  Â  -------------------------------------------------------------------

Â  Â  -- 6. Get dynamic headers from file

Â  Â  -------------------------------------------------------------------

Â  Â  FOR r IN (

Â  Â  Â  Â  SELECT column_position, column_name

Â  Â  Â  Â  Â  FROM TABLE(apex_data_parser.get_columns(v_profile_clob))

Â  Â  Â  Â  Â ORDER BY column_position

Â  Â  ) LOOP

Â  Â  Â  Â  v_headers(r.column_position) := r.column_name;

Â  Â  Â  Â  v_col_count := r.column_position;

Â  Â  END LOOP;



Â  Â  INSERT INTO debug_log(message) VALUES('Detected ' || v_col_count || ' columns from file.');

Â  Â  IF v_col_count = 0 THEN

Â  Â  Â  Â  RAISE_APPLICATION_ERROR(-20001, 'No columns detected in uploaded file.');

Â  Â  END IF;



Â  Â  -------------------------------------------------------------------

Â  Â  -- 7. Build JSON SQL

Â  Â  -------------------------------------------------------------------

Â  Â  v_sql_json := 'SELECT p.line_number, JSON_OBJECT(';

Â  Â  FOR i IN 1..v_col_count LOOP

Â  Â  Â  Â  IF i > 1 THEN v_sql_json := v_sql_json || ', '; END IF;

Â  Â  Â  Â  v_sql_json := v_sql_json || '''' || REPLACE(v_headers(i), '''', '''''') || ''' VALUE NVL(p.col' || LPAD(i,3,'0') || ', '''')';

Â  Â  END LOOP;

Â  Â  v_sql_json := v_sql_json || ') AS row_json FROM TABLE(apex_data_parser.parse(p_content => :1, p_file_name => :2, p_skip_rows => 1)) p';



Â  Â  INSERT INTO debug_log(message) VALUES('Built SQL for JSON parse (len=' || LENGTH(v_sql_json) || ')');



Â  Â  -------------------------------------------------------------------

Â  Â  -- 8. Process each row

Â  Â  -------------------------------------------------------------------

Â  Â  OPEN c FOR v_sql_json USING l_blob, l_file_name;

Â  Â  LOOP

Â  Â  Â  Â  FETCH c INTO v_line_number, v_row_json;

Â  Â  Â  Â  EXIT WHEN c%NOTFOUND;



Â  Â  Â  Â  l_total_rows := l_total_rows + 1;

Â  Â  Â  Â  INSERT INTO debug_log(message) VALUES('--- Processing row #' || l_total_rows || ' line=' || NVL(TO_CHAR(v_line_number),'N/A'));



Â  Â  Â  Â  -- Reset dynamic variables

Â  Â  Â  Â  l_cols := NULL;

Â  Â  Â  Â  l_vals := NULL;

Â  Â  Â  Â  l_setÂ  := NULL;

Â  Â  Â  Â  l_stay_val := NULL;



Â  Â  Â  Â  BEGIN

Â  Â  Â  Â  Â  Â  DECLARE

Â  Â  Â  Â  Â  Â  Â  Â  l_elem JSON_ELEMENT_T := JSON_ELEMENT_T.parse(v_row_json);

Â  Â  Â  Â  Â  Â  Â  Â  l_objÂ  JSON_OBJECT_T;

Â  Â  Â  Â  Â  Â  Â  Â  l_keys JSON_KEY_LIST;

Â  Â  Â  Â  Â  Â  Â  Â  l_colÂ  VARCHAR2(4000);

Â  Â  Â  Â  Â  Â  Â  Â  l_valÂ  VARCHAR2(4000);

Â  Â  Â  Â  Â  Â  Â  Â  l_val_formatted VARCHAR2(4000);

Â  Â  Â  Â  Â  Â  BEGIN

Â  Â  Â  Â  Â  Â  Â  Â  IF NOT l_elem.is_object THEN

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  RAISE_APPLICATION_ERROR(-20002,'Row not a JSON object');

Â  Â  Â  Â  Â  Â  Â  Â  END IF;



Â  Â  Â  Â  Â  Â  Â  Â  l_obj := TREAT(l_elem AS JSON_OBJECT_T);

Â  Â  Â  Â  Â  Â  Â  Â  l_keys := l_obj.get_keys;



Â  Â  Â  Â  Â  Â  Â  Â  FOR j IN 1..l_keys.count LOOP

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  --l_col := UPPER(REPLACE(REPLACE(l_keys(j), '__', '_'), ' ', '_'));

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  l_col := sanitize_column_name(l_keys(j));



Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  l_val := l_obj.get_string(l_keys(j));



Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  -- Capture STAY_DATE value

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  IF l_stay_col_name IS NOT NULL AND l_col = UPPER(l_stay_col_name) THEN

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  l_stay_val := l_val;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  END IF;



Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  -- Format value

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  l_val_formatted := NULL;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  IF l_val IS NOT NULL AND REGEXP_LIKE(l_val,'^-?\d+(\.\d+)?$') THEN

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  l_val_formatted := TO_CHAR(TO_NUMBER(l_val));

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  END IF;



Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  IF l_val_formatted IS NULL THEN

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  l_val_formatted := '''' || REPLACE(NVL(l_val,''), '''', '''''') || '''';

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  END IF;



Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  -- Append to dynamic SQL parts

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  IF l_set IS NOT NULL THEN

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  l_setÂ  := l_set || ', ';

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  l_cols := l_cols || ', ';

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  l_vals := l_vals || ', ';

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  END IF;



Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  l_setÂ  := NVL(l_set,'')Â  || l_col || ' = ' || l_val_formatted;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  l_cols := NVL(l_cols,'') || l_col;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  l_vals := NVL(l_vals,'') || l_val_formatted;

Â  Â  Â  Â  Â  Â  Â  Â  END LOOP;



Â  Â  Â  Â  Â  Â  Â  Â  -- Always append HOTEL_ID to the set/insert

IF NVL(l_cols,'') <> '' THEN

Â l_cols := l_cols || ', HOTEL_ID';

l_vals := l_vals || ', HEXTORAW(''' || RAWTOHEX(p_hotel_id) || ''')';



Â  Â  l_setÂ  := l_setÂ  || ', HOTEL_ID = ''' || p_hotel_id || '''';

END IF;



----------------------------------------------------------------

-- UPSERT logic (update first, then insert)

----------------------------------------------------------------

-- Hardcoded hotel_id for testing

/*l_sql := 'UPDATE ' || l_table_name ||Â 

Â  Â  Â  Â  Â ' SET ' || l_set ||Â 

Â  Â  Â  Â  Â ' WHERE HOTEL_ID = HEXTORAW(''3B9B828094379CA8E063DD59000AC846'')' ||

Â  Â  Â  Â  Â ' AND STAY_DATE = ''03-08-2025''';*/

Â  Â  Â  Â  Â l_sql := 'UPDATE ' || l_table_name ||Â 

Â  Â  Â  Â  Â ' SET ' || l_set ||Â 

Â  Â  Â  Â  Â ' WHERE HOTEL_ID = HEXTORAW(''' || RAWTOHEX(p_hotel_id) || ''')';



-- Optional: include STAY_DATE if available

IF l_stay_val IS NOT NULL THEN

Â  Â  l_sql := l_sql || ' AND ' || l_stay_col_name || ' = ''' || REPLACE(l_stay_val,'''','''''') || '''';

END IF;







-- Debug

INSERT INTO debug_log(message) VALUES('UPDATE SQL: ' || SUBSTR(l_sql,1,2000));



EXECUTE IMMEDIATE l_sql;



Â  Â  Â  Â  Â  Â  Â  Â  /*IF l_stay_col_name IS NOT NULL AND l_stay_val IS NOT NULL THEN

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  l_sql := l_sql || ' AND ' || l_stay_col_name || ' = ''' || REPLACE(l_stay_val,'''','''''') || '''';

Â  Â  Â  Â  Â  Â  Â  Â  END IF;*/



Â  Â  Â  Â  Â  Â  Â  Â  --INSERT INTO debug_log(message) VALUES('UPDATE SQL: ' || SUBSTR(l_sql,1,2000));

Â  Â  Â  Â  Â  Â  Â  Â  --EXECUTE IMMEDIATE l_sql;

Â  Â  Â  Â  Â  Â  Â  Â Â 

Â  Â  Â  Â  Â  Â  Â  Â  IF SQL%ROWCOUNT = 0 THEN

Â  Â  -- No row updated â†’ INSERT

Â  Â  l_cols := l_cols || ', HOTEL_ID';

Â  Â  l_vals := l_vals || ', HEXTORAW(''' || RAWTOHEX(p_hotel_id) || ''')';



Â  Â  l_sql := 'INSERT INTO ' || l_table_name || ' (' || l_cols || ') VALUES (' || l_vals || ')';

Â  Â  INSERT INTO debug_log(message) VALUES('INSERT SQL: ' || SUBSTR(l_sql,1,2000));

Â  Â  EXECUTE IMMEDIATE l_sql;

END IF;





Â  Â  Â  Â  Â  Â  Â  Â  l_success_cnt := l_success_cnt + 1;



Â  Â  Â  Â  Â  Â  END;

Â  Â  Â  Â  EXCEPTION

Â  Â  Â  Â  Â  Â  WHEN OTHERS THEN

Â  Â  Â  Â  Â  Â  Â  Â  l_fail_cnt := l_fail_cnt + 1;

Â  Â  Â  Â  Â  Â  Â  Â  l_error_json := l_error_json || '{"row":' || l_total_rows || ',"error":"' || REPLACE(SQLERRM,'"','''') || '"},';

Â  Â  Â  Â  END;

Â  Â  END LOOP;

Â  Â  CLOSE c;



Â  Â  -- finalize error JSON

Â  Â  IF l_error_json IS NOT NULL AND l_error_json <> '[' THEN

Â  Â  Â  Â  IF SUBSTR(l_error_json,-1) = ',' THEN

Â  Â  Â  Â  Â  Â  l_error_json := SUBSTR(l_error_json,1,LENGTH(l_error_json)-1);

Â  Â  Â  Â  END IF;

Â  Â  Â  Â  l_error_json := l_error_json || ']';

Â  Â  ELSE

Â  Â  Â  Â  l_error_json := NULL;

Â  Â  END IF;



Â  Â  COMMIT;



Â  Â  -- Update log

Â  Â  UPDATE ur_interface_logs

Â  Â  Â  Â SET load_end_time = systimestamp,

Â  Â  Â  Â  Â  Â load_statusÂ  Â = 'SUCCESS',

Â  Â  Â  Â  Â  Â updated_onÂ  Â  = sysdate,

Â  Â  Â  Â  Â  Â error_jsonÂ  Â  = l_error_json

Â  Â  Â WHERE id = l_log_id;



Â  Â  p_statusÂ  := TRUE;

Â  Â  p_message := 'Success: Upload completed â†’ Total=' || l_total_rows || ', Success=' || l_success_cnt || ', Failed=' || l_fail_cnt;



Â  Â  INSERT INTO debug_log(message) VALUES('Completed Load_Data - ' || p_message);



EXCEPTION

Â  Â  WHEN OTHERS THEN

Â  Â  Â  Â  BEGIN

Â  Â  Â  Â  Â  Â  UPDATE ur_interface_logs

Â  Â  Â  Â  Â  Â  Â  Â SET load_end_time = systimestamp,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â load_statusÂ  Â = 'FAILED',

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â updated_onÂ  Â  = sysdate

Â  Â  Â  Â  Â  Â  Â WHERE id = l_log_id;

Â  Â  Â  Â  EXCEPTION WHEN OTHERS THEN NULL;

Â  Â  Â  Â  END;



Â  Â  Â  Â  ROLLBACK;

Â  Â  Â  Â  p_status := FALSE;

Â  Â  Â  Â  p_message := 'Failure: ' || SQLERRM;

END Load_Data;









PROCEDURE fetch_templates(

Â  Â  p_file_idÂ  Â  Â  IN NUMBER,

Â  Â  p_hotel_idÂ  Â  Â IN VARCHAR2,

Â  Â  p_min_scoreÂ  Â  IN NUMBER DEFAULT 90,

Â  Â  p_debug_flagÂ  Â IN VARCHAR2 DEFAULT 'N',

Â  Â  p_output_jsonÂ  OUT CLOB,

Â  Â  p_statusÂ  Â  Â  Â OUT VARCHAR2,

Â  Â  p_messageÂ  Â  Â  OUT VARCHAR2

) IS

Â  Â  -- Local types

Â  Â  TYPE t_name_type_rec IS RECORD(

Â  Â  Â  Â  nameÂ  Â  Â  Â VARCHAR2(100),

Â  Â  Â  Â  data_typeÂ  VARCHAR2(30)

Â  Â  );

Â  Â  TYPE t_name_type_tab IS TABLE OF t_name_type_rec;



Â  Â  TYPE t_template_rec IS RECORD(

Â  Â  Â  Â  idÂ  Â  Â  Â  Â VARCHAR2(50),

Â  Â  Â  Â  nameÂ  Â  Â  Â VARCHAR2(200),

Â  Â  Â  Â  definition t_name_type_tab

Â  Â  );

Â  Â  TYPE t_template_tab IS TABLE OF t_template_rec INDEX BY PLS_INTEGER;



Â  Â  -- Variables

Â  Â  v_source_clobÂ  Â  Â  Â CLOB;

Â  Â  v_source_normalized CLOB;

Â  Â Â 

Â  Â  v_target_idÂ  Â  Â  Â  Â VARCHAR2(50);

Â  Â  v_target_nameÂ  Â  Â  Â VARCHAR2(200);

Â  Â  v_target_def_clobÂ  Â CLOB;

Â  Â  v_target_normalized CLOB;



Â  Â  v_source_defsÂ  Â  Â  Â t_name_type_tab := t_name_type_tab();

Â  Â  v_target_defsÂ  Â  Â  Â t_name_type_tab := t_name_type_tab();



Â  Â  v_templatesÂ  Â  Â  Â  Â t_template_tab;

Â  Â  v_count_templatesÂ  Â PLS_INTEGER := 0;



Â  Â  v_json_outputÂ  Â  Â  Â CLOB := '[';

Â  Â  v_min_score_useÂ  Â  Â NUMBER;

Â  Â  v_separatorÂ  Â  Â  Â  Â VARCHAR2(1) := '';



Â  Â  v_match_countÂ  Â  Â  Â NUMBER;

Â  Â  v_scoreÂ  Â  Â  Â  Â  Â  Â NUMBER;



Â  Â  CURSOR c_targets IS

Â  Â  Â  SELECT ID, NAME, DEFINITION FROM UR_TEMPLATES WHERE hotel_id = p_hotel_id;



Â  Â  -- Debug procedure

Â  Â  PROCEDURE debug(p_msg VARCHAR2) IS

Â  Â  BEGIN

Â  Â  Â  Â  IF UPPER(p_debug_flag) = 'Y' THEN

Â  Â  Â  Â  Â  Â  DBMS_OUTPUT.PUT_LINE('[DEBUG] ' || p_msg);

Â  Â  Â  Â  END IF;

Â  Â  END;



Â  Â  -- Normalize data-type keys in JSON string (case sensitive replacement)

Â  Â  FUNCTION normalize_json(p_json CLOB) RETURN CLOB IS

Â  Â  BEGIN

Â  Â  Â  Â  RETURN REPLACE(REPLACE(p_json, '"data-type"', '"data_type"'), '"DATA-TYPE"', '"data_type"');

Â  Â  END;



Â  Â  -- Parse definition JSON into PL/SQL collection

Â  Â  FUNCTION parse_definition(p_clob CLOB) RETURN t_name_type_tab IS

Â  Â  Â  Â  l_defs t_name_type_tab := t_name_type_tab();

Â  Â  Â  Â  idxÂ  Â  Â PLS_INTEGER := 0;

Â  Â  BEGIN

Â  Â  Â  Â  FOR rec IN (

Â  Â  Â  Â  Â  Â  SELECT lower(trim(name)) AS name, lower(trim(data_type)) AS data_type FROM JSON_TABLE(

Â  Â  Â  Â  Â  Â  Â  Â  p_clob,

Â  Â  Â  Â  Â  Â  Â  Â  '$[*]' COLUMNS (

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  name VARCHAR2(100) PATH '$.name',

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  data_type VARCHAR2(30) PATH '$.data_type'

Â  Â  Â  Â  Â  Â  Â  Â  )

Â  Â  Â  Â  Â  Â  )

Â  Â  Â  Â  ) LOOP

Â  Â  Â  Â  Â  Â  idx := idx + 1;

Â  Â  Â  Â  Â  Â  l_defs.EXTEND;

Â  Â  Â  Â  Â  Â  l_defs(idx).name := rec.name;

Â  Â  Â  Â  Â  Â  l_defs(idx).data_type := rec.data_type;

Â  Â  Â  Â  END LOOP;

Â  Â  Â  Â  RETURN l_defs;

Â  Â  EXCEPTION

Â  Â  Â  Â  WHEN OTHERS THEN

Â  Â  Â  Â  Â  Â  RETURN NULL;

Â  Â  END;



Â  Â  -- Count matches (name + data_type case-insensitive)

Â  Â  FUNCTION count_matches(p_source t_name_type_tab, p_target t_name_type_tab) RETURN NUMBER IS

Â  Â  Â  Â  v_count NUMBER := 0;

Â  Â  BEGIN

Â  Â  Â  Â  FOR i IN 1 .. p_source.COUNT LOOP

Â  Â  Â  Â  Â  Â  FOR j IN 1 .. p_target.COUNT LOOP

Â  Â  Â  Â  Â  Â  Â  Â  IF p_source(i).name = p_target(j).name AND p_source(i).data_type = p_target(j).data_type THEN

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  v_count := v_count + 1;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  EXIT;

Â  Â  Â  Â  Â  Â  Â  Â  END IF;

Â  Â  Â  Â  Â  Â  END LOOP;

Â  Â  Â  Â  END LOOP;

Â  Â  Â  Â  RETURN v_count;

Â  Â  END;



BEGIN

Â  Â  -- Validate inputs and assign to local variable

Â  Â  v_min_score_use := NVL(p_min_score, 90);

Â  Â  IF v_min_score_use < 0 OR v_min_score_use > 100 THEN

Â  Â  Â  Â  v_min_score_use := 90;

Â  Â  END IF;



Â  Â  IF p_file_id IS NULL THEN

Â  Â  Â  Â  p_status := 'E';

Â  Â  Â  Â  p_message := 'File ID must be provided';

Â  Â  Â  Â  p_output_json := NULL;

Â  Â  Â  Â  RETURN;

Â  Â  END IF;



Â  Â  IF p_hotel_id IS NULL THEN

Â  Â  Â  Â  p_status := 'E';

Â  Â  Â  Â  p_message := 'Hotel ID must be provided';

Â  Â  Â  Â  p_output_json := NULL;

Â  Â  Â  Â  RETURN;

Â  Â  END IF;



Â  Â  debug('Starting processing...');

Â  Â  debug('File ID: ' || p_file_id);

Â  Â  debug('Hotel ID: ' || p_hotel_id);

Â  Â  debug('Minimum Score: ' || v_min_score_use);



Â  Â  -- Fetch and normalize source CLOB

Â  Â  BEGIN

Â  Â  Â  Â  SELECT columns INTO v_source_clob FROM temp_blob WHERE id = p_file_id;

Â  Â  Â  Â  IF v_source_clob IS NULL THEN

Â  Â  Â  Â  Â  Â  p_status := 'E';

Â  Â  Â  Â  Â  Â  p_message := 'Source definition not found for file_id ' || p_file_id;

Â  Â  Â  Â  Â  Â  p_output_json := NULL;

Â  Â  Â  Â  Â  Â  RETURN;

Â  Â  Â  Â  END IF;

Â  Â  EXCEPTION

Â  Â  Â  Â  WHEN NO_DATA_FOUND THEN

Â  Â  Â  Â  Â  Â  p_status := 'E';

Â  Â  Â  Â  Â  Â  p_message := 'Source file not found for id ' || p_file_id;

Â  Â  Â  Â  Â  Â  p_output_json := NULL;

Â  Â  Â  Â  Â  Â  RETURN;

Â  Â  Â  Â  WHEN OTHERS THEN

Â  Â  Â  Â  Â  Â  p_status := 'E';

Â  Â  Â  Â  Â  Â  p_message := 'Error fetching source definition: ' || SQLERRM;

Â  Â  Â  Â  Â  Â  p_output_json := NULL;

Â  Â  Â  Â  Â  Â  RETURN;

Â  Â  END;



Â  Â  v_source_normalized := normalize_json(v_source_clob);



Â  Â  -- Parse source defs

Â  Â  v_source_defs := parse_definition(v_source_normalized);

Â  Â  IF v_source_defs IS NULL OR v_source_defs.COUNT = 0 THEN

Â  Â  Â  Â  p_status := 'E';

Â  Â  Â  Â  p_message := 'Cannot parse source definition JSON or empty definition';

Â  Â  Â  Â  p_output_json := NULL;

Â  Â  Â  Â  RETURN;

Â  Â  END IF;

Â  Â  debug('Parsed Source definitions: ' || v_source_defs.COUNT || ' fields');



Â  Â  -- Initialize JSON output

Â  Â  v_json_output := '[';

Â  Â  v_count_templates := 0;



Â  Â  -- Loop over target templates from cursor

Â  Â  FOR r_target IN c_targets LOOP

Â  Â  Â  Â  v_target_id := r_target.ID;

Â  Â  Â  Â  v_target_name := r_target.NAME;

Â  Â  Â  Â  v_target_def_clob := r_target.DEFINITION;



Â  Â  Â  Â  IF v_target_def_clob IS NULL THEN

Â  Â  Â  Â  Â  Â  debug('Skipping template ' || v_target_id || ' due to NULL definition');

Â  Â  Â  Â  Â  Â  CONTINUE;

Â  Â  Â  Â  END IF;



Â  Â  Â  Â  v_target_normalized := normalize_json(v_target_def_clob);



Â  Â  Â  Â  v_target_defs := parse_definition(v_target_normalized);

Â  Â  Â  Â  IF v_target_defs IS NULL OR v_target_defs.COUNT = 0 THEN

Â  Â  Â  Â  Â  Â  debug('Skipping template ' || v_target_id || ' due to parsing error or empty definition');

Â  Â  Â  Â  Â  Â  CONTINUE;

Â  Â  Â  Â  END IF;



Â  Â  Â  Â  v_match_count := count_matches(v_source_defs, v_target_defs);



Â  Â  Â  Â  v_score := ROUND((2 * v_match_count) / (v_source_defs.COUNT + v_target_defs.COUNT) * 100);



Â  Â  Â  Â  debug('Template ' || v_target_id || ' (' || v_target_name || '): Matches=' ||Â 

Â  Â  Â  Â  Â  Â  Â  v_match_count || ', Score=' || v_score);



Â  Â  Â  Â  IF v_score >= v_min_score_use THEN

Â  Â  Â  Â  Â  Â  IF v_count_templates > 0 THEN

Â  Â  Â  Â  Â  Â  Â  Â  v_json_output := v_json_output || ',';

Â  Â  Â  Â  Â  Â  END IF;

Â  Â  Â  Â  Â  Â  v_json_output := v_json_output || '{"Template_id":"' || v_target_id ||Â 

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  '","Template_Name":"' || REPLACE(v_target_name,'"','\"') ||Â 

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  '","Score":' || v_score || '}';

Â  Â  Â  Â  Â  Â  v_count_templates := v_count_templates + 1;

Â  Â  Â  Â  END IF;

Â  Â  END LOOP;



Â  Â  v_json_output := v_json_output || ']';



Â  Â  IF v_count_templates = 0 THEN

Â  Â  Â  Â  p_output_json := '[{}]';

Â  Â  Â  Â  p_message := 'No templates matched the minimum score threshold';

Â  Â  Â  Â  debug('No matching templates found.');

Â  Â  ELSE

Â  Â  Â  Â  p_output_json := v_json_output;

Â  Â  Â  Â  p_message := 'Templates matched: ' || v_count_templates;

Â  Â  Â  Â  debug('Matching templates count: ' || v_count_templates);

Â  Â  END IF;



Â  Â  p_status := 'S';



EXCEPTION

Â  Â  WHEN OTHERS THEN

Â  Â  Â  Â  p_status := 'E';

Â  Â  Â  Â  p_message := 'Unexpected error: ' || SQLERRM;

Â  Â  Â  Â  p_output_json := NULL;

END fetch_templates;



PROCEDURE DELETE_TEMPLATES (

Â  Â  p_idÂ  Â  Â  Â  Â  Â  IN VARCHAR2 DEFAULT NULL,

Â  Â  p_hotel_idÂ  Â  Â  IN VARCHAR2 DEFAULT NULL,

Â  Â  p_keyÂ  Â  Â  Â  Â  Â IN VARCHAR2 DEFAULT NULL,

Â  Â  p_nameÂ  Â  Â  Â  Â  IN VARCHAR2 DEFAULT NULL,

Â  Â  p_typeÂ  Â  Â  Â  Â  IN VARCHAR2 DEFAULT NULL,

Â  Â  p_activeÂ  Â  Â  Â  IN CHAR DEFAULT NULL,

Â  Â  p_db_obj_emptyÂ  IN CHAR DEFAULT NULL,

Â  Â  p_delete_allÂ  Â  IN CHAR DEFAULT 'N',

Â  Â  p_debugÂ  Â  Â  Â  Â IN CHAR DEFAULT 'N',

Â  Â  p_json_outputÂ  Â OUT CLOB

Â  )

Â  AS

Â  Â  v_sqlÂ  Â  Â  Â  Â  Â  VARCHAR2(1000);

Â  Â  v_rows_countÂ  Â  Â NUMBER;

Â  Â  v_statusÂ  Â  Â  Â  Â CHAR(1);

Â  Â  v_messageÂ  Â  Â  Â  VARCHAR2(4000);

Â  Â  v_json_listÂ  Â  Â  CLOB := '[';

Â  Â  v_firstÂ  Â  Â  Â  Â  BOOLEAN := TRUE;



Â  Â  CURSOR c_templates IS

Â  Â  Â  SELECT id, hotel_id, key, name, type, active, db_object_name

Â  Â  Â  FROM ur_templates

Â  Â  Â  WHERE (p_delete_all = 'Y'

Â  Â  Â  Â  Â  Â  OR (p_id IS NULL OR id = p_id))

Â  Â  Â  Â  AND (p_delete_all = 'Y'

Â  Â  Â  Â  Â  Â  Â OR (p_hotel_id IS NULL OR hotel_id = p_hotel_id))

Â  Â  Â  Â  AND (p_delete_all = 'Y'

Â  Â  Â  Â  Â  Â  Â OR (p_key IS NULL OR key = p_key))

Â  Â  Â  Â  AND (p_delete_all = 'Y'

Â  Â  Â  Â  Â  Â  Â OR (p_name IS NULL OR name = p_name))

Â  Â  Â  Â  AND (p_delete_all = 'Y'

Â  Â  Â  Â  Â  Â  Â OR (p_type IS NULL OR type = p_type))

Â  Â  Â  Â  AND (p_delete_all = 'Y'

Â  Â  Â  Â  Â  Â  Â OR (p_active IS NULL OR active = p_active));



Â  Â  -- Helper to escape JSON strings (basic)

Â  Â  FUNCTION json_escape(str IN VARCHAR2) RETURN VARCHAR2 IS

Â  Â  BEGIN

Â  Â  Â  RETURN REPLACE(REPLACE(REPLACE(REPLACE(str, '\', '\\'), '"', '\"'), CHR(10), '\n'), CHR(13), '');

Â  Â  EXCEPTION WHEN OTHERS THEN

Â  Â  Â  RETURN '';

Â  Â  END;



Â  Â  PROCEDURE dbg(p_msg VARCHAR2) IS

Â  Â  BEGIN

Â  Â  Â  IF p_debug = 'Y' THEN

Â  Â  Â  Â  apex_debug.message(p_msg);

Â  Â  Â  END IF;

Â  Â  END;



Â  Â  PROCEDURE append_result (

Â  Â  Â  p_idÂ  Â  Â  Â  Â  Â  IN VARCHAR2,

Â  Â  Â  p_hotel_idÂ  Â  Â  IN VARCHAR2,

Â  Â  Â  p_keyÂ  Â  Â  Â  Â  Â IN VARCHAR2,

Â  Â  Â  p_nameÂ  Â  Â  Â  Â  IN VARCHAR2,

Â  Â  Â  p_typeÂ  Â  Â  Â  Â  IN VARCHAR2,

Â  Â  Â  p_activeÂ  Â  Â  Â  IN CHAR,

Â  Â  Â  p_db_obj_nameÂ  Â IN VARCHAR2,

Â  Â  Â  p_statusÂ  Â  Â  Â  IN CHAR,

Â  Â  Â  p_messageÂ  Â  Â  Â IN VARCHAR2

Â  Â  ) IS

Â  Â  BEGIN

Â  Â  Â  IF v_first THEN

Â  Â  Â  Â  v_first := FALSE;

Â  Â  Â  ELSE

Â  Â  Â  Â  v_json_list := v_json_list || ',';

Â  Â  Â  END IF;



Â  Â  Â  v_json_list := v_json_list || '{' ||

Â  Â  Â  Â  '"id":"'Â  Â  Â  Â  Â  || json_escape(p_id)Â  Â  Â  Â  Â  || '",' ||

Â  Â  Â  Â  '"hotel_id":"'Â  Â  || json_escape(p_hotel_id)Â  Â  || '",' ||

Â  Â  Â  Â  '"key":"'Â  Â  Â  Â  Â || json_escape(p_key)Â  Â  Â  Â  Â || '",' ||

Â  Â  Â  Â  '"name":"'Â  Â  Â  Â  || json_escape(p_name)Â  Â  Â  Â  || '",' ||

Â  Â  Â  Â  '"type":"'Â  Â  Â  Â  || json_escape(p_type)Â  Â  Â  Â  || '",' ||

Â  Â  Â  Â  '"active":"'Â  Â  Â  || json_escape(p_active)Â  Â  Â  || '",' ||

Â  Â  Â  Â  '"db_object_name":"' || json_escape(p_db_obj_name) || '",' ||

Â  Â  Â  Â  '"status":"'Â  Â  Â  || json_escape(p_status)Â  Â  Â  || '",' ||

Â  Â  Â  Â  '"message":"'Â  Â  Â || json_escape(p_message)Â  Â  Â || '"' ||

Â  Â  Â  '}';

Â  Â  END;



Â  BEGIN

Â  Â  dbg('Started DELETE_TEMPLATES_AND_DB_OBJECTS_JSON procedure.');



Â  Â  FOR rec IN c_templates LOOP

Â  Â  Â  dbg('Processing template ID=' || rec.id || ', DB_OBJECT_NAME=' || rec.db_object_name);



Â  Â  Â  IF rec.db_object_name IS NULL THEN

Â  Â  Â  Â  v_status := 'E';

Â  Â  Â  Â  v_message := 'No DB_OBJECT_NAME specified for template, skipping.';

Â  Â  Â  Â  dbg(v_message);

Â  Â  Â  Â  append_result(rec.id, rec.hotel_id, rec.key, rec.name, rec.type, rec.active, NULL, v_status, v_message);

Â  Â  Â  Â  CONTINUE;

Â  Â  Â  END IF;



Â  Â  Â  -- Check if table exists in user schema

Â  Â  --Â  Â SELECT COUNT(*)

Â  Â  --Â  Â  Â INTO v_rows_count

Â  Â  --Â  Â  Â FROM all_tables

Â  Â  --Â  Â  WHERE table_name = rec.db_object_name

Â  Â  --Â  Â  Â  AND owner = USER;



Â  Â  --Â  Â IF v_rows_count = 0 THEN

Â  Â  --Â  Â  Â v_status := 'E';

Â  Â  --Â  Â  Â v_message := 'DB Object [' || rec.db_object_name || '] does not exist or is not a table.';

Â  Â  --Â  Â  Â dbg(v_message);

Â  Â  --Â  Â  Â append_result(rec.id, rec.hotel_id, rec.key, rec.name, rec.type, rec.active, rec.db_object_name, v_status, v_message);

Â  Â  --Â  Â  Â CONTINUE;

Â  Â  --Â  Â END IF;



Â  Â  Â  -- Check if table should be empty before deleting

Â  Â  Â  IF p_db_obj_empty = 'Y' THEN

Â  Â  Â  Â  v_sql := 'SELECT COUNT(*) FROM ' || rec.db_object_name;

Â  Â  Â  Â  BEGIN

Â  Â  Â  Â  Â  EXECUTE IMMEDIATE v_sql INTO v_rows_count;

Â  Â  Â  Â  EXCEPTION

Â  Â  Â  Â  Â  WHEN OTHERS THEN

Â  Â  Â  Â  Â  Â  v_rows_count := -1; -- can't count, treat as error or non-empty

Â  Â  Â  Â  END;



Â  Â  Â  Â  IF v_rows_count > 0 THEN

Â  Â  Â  Â  Â  v_status := 'E';

Â  Â  Â  Â  Â  v_message := 'DB Object table [' || rec.db_object_name || '] is not empty (ROWS=' || v_rows_count || '), skipping deletion.';

Â  Â  Â  Â  Â  dbg(v_message);

Â  Â  Â  Â  Â  append_result(rec.id, rec.hotel_id, rec.key, rec.name, rec.type, rec.active, rec.db_object_name, v_status, v_message);

Â  Â  Â  Â  Â  CONTINUE;

Â  Â  Â  Â  END IF;

Â  Â  Â  Â  dbg('DB Object table [' || rec.db_object_name || '] is empty, proceeding.');

Â  Â  Â  END IF;



Â  Â  Â  -- Try to drop the table and delete template

Â  Â  Â  BEGIN

Â  Â  Â  Â  v_sql := 'DROP TABLE ' || rec.db_object_name || ' CASCADE CONSTRAINTS';

Â  Â  Â  Â  dbg('Executing: ' || v_sql);

Â  Â  Â  Â  EXECUTE IMMEDIATE v_sql;



Â  Â  Â  Â  dbg('Dropped table ' || rec.db_object_name);



Â  Â  Â  Â  DELETE FROM ur_templates WHERE id = rec.id;



Â  Â  Â  Â  dbg('Deleted template id=' || rec.id);



Â  Â  Â  Â  v_status := 'S';

Â  Â  Â  Â  v_message := 'Successfully dropped table and deleted template.';

Â  Â  Â  Â  append_result(rec.id, rec.hotel_id, rec.key, rec.name, rec.type, rec.active, rec.db_object_name, v_status, v_message);



Â  Â  Â  EXCEPTION

Â  Â  Â  Â  WHEN OTHERS THEN

Â  Â  Â  Â  Â  v_status := 'E';

Â  Â  Â  Â  Â  v_message := 'Error dropping table or deleting template: ' || SQLERRM;

Â  Â  Â  Â  Â  dbg(v_message);

Â  Â  Â  Â  Â  append_result(rec.id, rec.hotel_id, rec.key, rec.name, rec.type, rec.active, rec.db_object_name, v_status, v_message);

Â  Â  Â  END;

Â  Â  END LOOP;



Â  Â  v_json_list := v_json_list || ']';



Â  Â  p_json_output := v_json_list;



Â  Â  dbg('Completed DELETE_TEMPLATES_AND_DB_OBJECTS_JSON procedure.');

Â  END DELETE_TEMPLATES;



PROCEDURE manage_algo_attributes(

Â  Â  p_template_keyÂ  Â INÂ  VARCHAR2,

Â  Â  p_modeÂ  Â  Â  Â  Â  Â INÂ  CHAR,

Â  Â  p_attribute_keyÂ  INÂ  VARCHAR2 DEFAULT NULL,

Â  Â  p_statusÂ  Â  Â  Â  Â OUT BOOLEAN,

Â  Â  p_messageÂ  Â  Â  Â  OUT VARCHAR2

) IS

Â  Â  v_db_object_nameÂ  Â  Â  Â  UR_TEMPLATES.DB_OBJECT_NAME%TYPE;

Â  Â  v_definitionÂ  Â  Â  Â  Â  Â  UR_TEMPLATES.DEFINITION%TYPE;

Â  Â  v_hotel_idÂ  Â  Â  Â  Â  Â  Â  UR_TEMPLATES.HOTEL_ID%TYPE;

Â  Â  v_template_idÂ  Â  Â  Â  Â  Â RAW(16);

Â  Â  v_template_typeÂ  Â  Â  Â  Â UR_TEMPLATES.TYPE%TYPE;

Â  Â  v_db_view_object_nameÂ  Â UR_TEMPLATES.DB_VIEW_OBJECT_NAME%TYPE;

Â  Â  v_user_idÂ  Â  Â  Â  Â  Â  Â  Â RAW(16);



Â  Â  v_insert_countÂ  Â NUMBER := 0;

Â  Â  v_update_countÂ  Â NUMBER := 0;

Â  Â  v_delete_countÂ  Â NUMBER := 0;



Â  Â  -- record and associative array types

Â  Â  TYPE t_attr IS RECORD (

Â  Â  Â  Â  name VARCHAR2(200),

Â  Â  Â  Â  data_type VARCHAR2(50),

Â  Â  Â  Â  qualifier VARCHAR2(50)

Â  Â  );

Â  Â  TYPE t_attr_tab IS TABLE OF t_attr INDEX BY VARCHAR2(200);



Â  Â  v_existing t_attr_tab;

Â  Â  v_newÂ  Â  Â  t_attr_tab;

Â  Â  v_keyÂ  Â  Â  VARCHAR2(200);



BEGIN

Â  Â  p_status := FALSE;

Â  Â  p_message := NULL;



Â  Â  ---------------------------------------------------------------------

Â  Â  -- Fetch Template Info

Â  Â  ---------------------------------------------------------------------

Â  Â  BEGIN

Â  Â  Â  Â  SELECT db_object_name, definition, id, hotel_id, type, db_view_object_name

Â  Â  Â  Â  Â  INTO v_db_object_name, v_definition, v_template_id, v_hotel_id, v_template_type, v_db_view_object_name

Â  Â  Â  Â  Â  FROM ur_templates

Â  Â  Â  Â  Â WHERE key = p_template_key;

Â  Â  EXCEPTION

Â  Â  Â  Â  WHEN NO_DATA_FOUND THEN

Â  Â  Â  Â  Â  Â  p_message := 'Failure: Template not found for key ' || p_template_key;

Â  Â  Â  Â  Â  Â  RETURN;

Â  Â  END;



Â  Â  ---------------------------------------------------------------------

Â  Â  -- Get Logged-in User ID

Â  Â  ---------------------------------------------------------------------

Â  Â  BEGIN

Â  Â  Â  Â  SELECT user_id

Â  Â  Â  Â  Â  INTO v_user_id

Â  Â  Â  Â  Â  FROM ur_users

Â  Â  Â  Â  Â WHERE user_name = SYS_CONTEXT('APEX$SESSION', 'APP_USER');

Â  Â  EXCEPTION

Â  Â  Â  Â  WHEN NO_DATA_FOUND THEN

Â  Â  Â  Â  Â  Â  v_user_id := NULL;

Â  Â  END;



Â  Â  ---------------------------------------------------------------------

Â  Â  -- CREATE MODE (C)

Â  Â  ---------------------------------------------------------------------

Â  Â  IF p_mode = 'C' THEN

Â  Â  Â  Â  DBMS_OUTPUT.PUT_LINE('=== CREATE MODE START ===');

Â  Â  Â  Â  DBMS_OUTPUT.PUT_LINE('Template: ' || p_template_key);

Â  Â  Â  Â  DBMS_OUTPUT.PUT_LINE('Object: ' || v_db_object_name);



Â  Â  Â  Â  IF v_definition IS NULL THEN

Â  Â  Â  Â  Â  Â  p_message := 'Failure: Definition JSON is NULL for template_key ' || p_template_key;

Â  Â  Â  Â  Â  Â  RETURN;

Â  Â  Â  Â  END IF;



FOR r IN (

Â  Â  SELECT UPPER(TRIM(jt.name)) AS name,

Â  Â  Â  Â  Â  Â NVL(UPPER(TRIM(jt.data_type)),'NUMBER') AS data_type,

Â  Â  Â  Â  Â  Â TRIM(UPPER(jt.qualifier)) AS qualifier

Â  Â  Â  FROM JSON_TABLE(v_definition,'$[*]'

Â  Â  Â  Â  Â  Â COLUMNS (

Â  Â  Â  Â  Â  Â  Â  Â name VARCHAR2(200) PATH '$.name',

Â  Â  Â  Â  Â  Â  Â  Â data_type VARCHAR2(50) PATH '$.data_type',

Â  Â  Â  Â  Â  Â  Â  Â qualifier VARCHAR2(50) PATH '$.qualifier'

Â  Â  Â  Â  Â  Â )) jt

) LOOP

Â  Â  -- Skip rows with no valid qualifier

Â  Â  IF r.qualifier IS NULL OR r.qualifier IN ('', '-', ' ') THEN

Â  Â  Â  Â  DBMS_OUTPUT.PUT_LINE('Skipping attribute (no valid qualifier): ' || r.name);

Â  Â  Â  Â  CONTINUE;

Â  Â  END IF;



Â  Â  v_key := UPPER(TRIM(v_db_object_name)) || '.' || UPPER(TRIM(r.name));



Â  Â  DBMS_OUTPUT.PUT_LINE('Inserting new attribute: ' || v_key ||Â 

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â ' | Qualifier: ' || r.qualifier ||Â 

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â ' | Data Type: ' || r.data_type);



Â  Â  INSERT INTO ur_algo_attributes (

Â  Â  Â  Â  id, algo_id, hotel_id, name, key, data_type, description, type,

Â  Â  Â  Â  value, template_id, attribute_qualifier,

Â  Â  Â  Â  created_by, updated_by, created_on, updated_on

Â  Â  ) VALUES (

Â  Â  Â  Â  SYS_GUID(), NULL, v_hotel_id, r.name, v_key,

Â  Â  Â  Â  r.data_type, NULL, 'S',

Â  Â  Â  Â  '#'||v_key||'#', v_template_id, r.qualifier,

Â  Â  Â  Â  v_user_id, v_user_id, SYSDATE, SYSDATE

Â  Â  );

Â  Â  v_insert_count := v_insert_count + 1;

END LOOP;



DBMS_OUTPUT.PUT_LINE('CREATE MODE: Total valid inserts: ' || v_insert_count);





Â  Â  Â  Â  COMMIT;



Â  Â  Â  Â  DBMS_OUTPUT.PUT_LINE('=== CREATE COMPLETE ===');

Â  Â  Â  Â  DBMS_OUTPUT.PUT_LINE('Inserted: ' || v_insert_count);



Â  Â  Â  Â  p_status := TRUE;

Â  Â  Â  Â  p_message := 'Success: '||v_insert_count||' attributes created for template_key '||p_template_key;



Â  Â  ---------------------------------------------------------------------

Â  Â  -- UPDATE MODE (U)

Â  Â  ---------------------------------------------------------------------

Â  Â  ELSIF p_mode = 'U' THEN

Â  Â  Â  Â  IF v_definition IS NULL THEN

Â  Â  Â  Â  Â  Â  p_message := 'Failure: Definition JSON is NULL for template_key ' || p_template_key;

Â  Â  Â  Â  Â  Â  RETURN;

Â  Â  Â  Â  END IF;



Â  Â  Â  Â  DBMS_OUTPUT.PUT_LINE('=== UPDATE MODE START ===');

Â  Â  Â  Â  DBMS_OUTPUT.PUT_LINE('Template: ' || p_template_key);

Â  Â  Â  Â  DBMS_OUTPUT.PUT_LINE('Object: ' || v_db_object_name);



Â  Â  Â  Â  -- Load existing attributes

Â  Â  Â  Â  FOR r IN (

Â  Â  Â  Â  Â  Â  SELECT name, data_type, NVL(attribute_qualifier,'-') AS qualifier, key

Â  Â  Â  Â  Â  Â  Â  FROM ur_algo_attributes

Â  Â  Â  Â  Â  Â  Â WHERE template_id = v_template_id

Â  Â  Â  Â  ) LOOP

Â  Â  Â  Â  Â  Â  v_key := UPPER(TRIM(r.key));

Â  Â  Â  Â  Â  Â  v_existing(v_key).name := r.name;

Â  Â  Â  Â  Â  Â  v_existing(v_key).data_type := NVL(r.data_type, 'NUMBER');

Â  Â  Â  Â  Â  Â  v_existing(v_key).qualifier := NVL(r.qualifier, '-');

Â  Â  Â  Â  Â  Â  DBMS_OUTPUT.PUT_LINE('Existing attribute: ' || v_key || ' Qualifier: ' || v_existing(v_key).qualifier);

Â  Â  Â  Â  END LOOP;



Â  Â  Â  Â  -- Load new attributes from JSON

Â  Â  Â  Â  FOR r IN (

Â  Â  Â  Â  Â  Â  SELECT UPPER(jt.name) AS name,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â NVL(UPPER(jt.data_type),'NUMBER') AS data_type,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â NVL(UPPER(jt.qualifier),'-') AS qualifier

Â  Â  Â  Â  Â  Â  Â  FROM JSON_TABLE(v_definition,'$[*]'

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â COLUMNS (

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â name VARCHAR2(200) PATH '$.name',

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â data_type VARCHAR2(50) PATH '$.data_type',

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â qualifier VARCHAR2(50) PATH '$.qualifier'

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â )) jt

Â  Â  Â  Â  ) LOOP

Â  Â  Â  Â  Â  Â  v_key := UPPER(TRIM(v_db_object_name)) || '.' || UPPER(TRIM(r.name));

Â  Â  Â  Â  Â  Â  v_new(v_key).name := r.name;

Â  Â  Â  Â  Â  Â  v_new(v_key).data_type := r.data_type;

Â  Â  Â  Â  Â  Â  v_new(v_key).qualifier := r.qualifier;

Â  Â  Â  Â  Â  Â  DBMS_OUTPUT.PUT_LINE('New attribute parsed: ' || v_key || ' Qualifier: ' || r.qualifier);

Â  Â  Â  Â  END LOOP;



Â  Â  Â  Â  ------------------------------------------------------------------

Â  Â  Â  Â  -- Compare and ACTUALLY update/insert/delete

Â  Â  Â  Â  ------------------------------------------------------------------

Â  Â  Â  Â  DECLARE

Â  Â  v_cur_key VARCHAR2(200);

BEGIN

Â  Â  -- Handle inserts + updates

Â  Â  v_cur_key := v_new.FIRST;

Â  Â  WHILE v_cur_key IS NOT NULL LOOP

Â  Â  Â  Â  -- Skip if qualifier invalid

Â  Â  Â  Â  IF v_new(v_cur_key).qualifier IS NULL OR v_new(v_cur_key).qualifier IN ('', '-', ' ') THEN

Â  Â  Â  Â  Â  Â  DBMS_OUTPUT.PUT_LINE('Skipping update/insert (invalid qualifier): ' || v_cur_key);

Â  Â  Â  Â  Â  Â  v_cur_key := v_new.NEXT(v_cur_key);

Â  Â  Â  Â  Â  Â  CONTINUE;

Â  Â  Â  Â  END IF;



Â  Â  Â  Â  IF v_existing.EXISTS(v_cur_key) THEN

Â  Â  Â  Â  Â  Â  -- Compare and update qualifier if changed

Â  Â  Â  Â  Â  Â  IF v_existing(v_cur_key).qualifier != v_new(v_cur_key).qualifier THEN

Â  Â  Â  Â  Â  Â  Â  Â  DBMS_OUTPUT.PUT_LINE('Updating qualifier for key: ' || v_cur_key ||

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â ' From: ' || v_existing(v_cur_key).qualifier ||

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â ' To: ' || v_new(v_cur_key).qualifier);



Â  Â  Â  Â  Â  Â  Â  Â  UPDATE ur_algo_attributes

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â SET attribute_qualifier = v_new(v_cur_key).qualifier,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â updated_by = v_user_id,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â updated_on = SYSDATE

Â  Â  Â  Â  Â  Â  Â  Â  Â WHERE key = v_cur_key;



Â  Â  Â  Â  Â  Â  Â  Â  v_update_count := v_update_count + SQL%ROWCOUNT;

Â  Â  Â  Â  Â  Â  END IF;

Â  Â  Â  Â  ELSE

Â  Â  Â  Â  Â  Â  DBMS_OUTPUT.PUT_LINE('Inserting new attribute: ' || v_cur_key ||

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â ' Qualifier: ' || v_new(v_cur_key).qualifier);



Â  Â  Â  Â  Â  Â  INSERT INTO ur_algo_attributes (

Â  Â  Â  Â  Â  Â  Â  Â  id, algo_id, hotel_id, name, key, data_type, description, type,

Â  Â  Â  Â  Â  Â  Â  Â  value, template_id, attribute_qualifier,

Â  Â  Â  Â  Â  Â  Â  Â  created_by, updated_by, created_on, updated_on

Â  Â  Â  Â  Â  Â  ) VALUES (

Â  Â  Â  Â  Â  Â  Â  Â  SYS_GUID(), NULL, v_hotel_id, v_new(v_cur_key).name, v_cur_key,

Â  Â  Â  Â  Â  Â  Â  Â  v_new(v_cur_key).data_type, NULL, 'S',

Â  Â  Â  Â  Â  Â  Â  Â  '#'||v_cur_key||'#', v_template_id, v_new(v_cur_key).qualifier,

Â  Â  Â  Â  Â  Â  Â  Â  v_user_id, v_user_id, SYSDATE, SYSDATE

Â  Â  Â  Â  Â  Â  );

Â  Â  Â  Â  Â  Â  v_insert_count := v_insert_count + 1;

Â  Â  Â  Â  END IF;

Â  Â  Â  Â  v_cur_key := v_new.NEXT(v_cur_key);

Â  Â  END LOOP;



Â  Â  -- Handle deletions

Â  Â  v_cur_key := v_existing.FIRST;

Â  Â  WHILE v_cur_key IS NOT NULL LOOP

Â  Â  Â  Â  IF NOT v_new.EXISTS(v_cur_key) THEN

Â  Â  Â  Â  Â  Â  DBMS_OUTPUT.PUT_LINE('Deleting old attribute: ' || v_cur_key);

Â  Â  Â  Â  Â  Â  DELETE FROM ur_algo_attributes WHERE key = v_cur_key;

Â  Â  Â  Â  Â  Â  v_delete_count := v_delete_count + SQL%ROWCOUNT;

Â  Â  Â  Â  END IF;

Â  Â  Â  Â  v_cur_key := v_existing.NEXT(v_cur_key);

Â  Â  END LOOP;

END;



Â  Â  Â  Â  COMMIT;



Â  Â  Â  Â  DBMS_OUTPUT.PUT_LINE('=== SUMMARY ===');

Â  Â  Â  Â  DBMS_OUTPUT.PUT_LINE('Inserted: ' || v_insert_count);

Â  Â  Â  Â  DBMS_OUTPUT.PUT_LINE('Updated: ' || v_update_count);

Â  Â  Â  Â  DBMS_OUTPUT.PUT_LINE('Deleted: ' || v_delete_count);



Â  Â  Â  Â  p_status := TRUE;

Â  Â  Â  Â  p_message := 'Success: '||v_insert_count||' inserted, '||v_update_count||' updated, '||v_delete_count||' deleted for template_key '||p_template_key;



Â  Â  ---------------------------------------------------------------------

Â  Â  -- INVALID MODE

Â  Â  ---------------------------------------------------------------------

Â  Â  ELSE

Â  Â  Â  Â  p_message := 'Failure: Invalid mode ' || p_mode || '. Use C or U.';

Â  Â  Â  Â  p_status := FALSE;

Â  Â  END IF;



EXCEPTION

Â  Â  WHEN OTHERS THEN

Â  Â  Â  Â  ROLLBACK;

Â  Â  Â  Â  p_status := FALSE;

Â  Â  Â  Â  p_message := 'Failure: ' || SQLERRM;

Â  Â  Â  Â  DBMS_OUTPUT.PUT_LINE('*** ERROR: ' || SQLERRM);

END manage_algo_attributes;













procedure add_alert(

Â  Â  p_existing_json in clob,

Â  Â  p_message in varchar2,

Â  Â  p_icon in varchar2 default null,

Â  Â  p_title in varchar2 default null,

Â  Â  p_timeout in number default null,

Â  Â  p_updated_json out clob

) is

Â  Â  l_json_array json_array_t;

Â  Â  l_new_object json_object_t;

begin

Â  Â  -- Create the new JSON object

Â  Â  l_new_object := new json_object_t();

Â  Â  l_new_object.put('message', p_message);

Â  Â  l_new_object.put('icon', nvl(p_icon, 'success'));

Â  Â  l_new_object.put('title', nvl(p_title, ''));



Â  Â  if p_timeout is not null then

Â  Â  Â  Â  l_new_object.put('timeOut', to_char(p_timeout));

Â  Â  end if;



Â  Â  -- Append the new object to the existing array or create a new array

Â  Â  if p_existing_json is null or trim(p_existing_json) = '' then

Â  Â  Â  Â  -- Create a new array with the new object

Â  Â  Â  Â  l_json_array := new json_array_t();

Â  Â  else

Â  Â  Â  Â  -- Parse the existing JSON string into a JSON array

Â  Â  Â  Â  l_json_array := json_array_t(p_existing_json);

Â  Â  end if;



Â  Â  -- Append the new object

Â  Â  l_json_array.append(l_new_object);



Â  Â  -- Convert the JSON array back to a CLOB

Â  Â  p_updated_json := l_json_array.to_clob;

end add_alert;



PROCEDURE validate_expression (

Â  Â  p_expression IN VARCHAR2,

Â  Â  p_mode IN CHAR,

Â  Â  p_hotel_id IN VARCHAR2,

Â  Â  p_status OUT VARCHAR2, -- 'S' or 'E'

Â  Â  p_message OUT VARCHAR2

) IS

Â  TYPE t_str_list IS TABLE OF VARCHAR2(100) INDEX BY PLS_INTEGER;

Â  v_attributes t_str_list;

Â  v_functions t_str_list;

Â  v_operators t_str_list;

Â  v_attr_count NUMBER := 0;

Â  v_func_count NUMBER := 0;

Â  v_oper_count NUMBER := 0;



Â  TYPE t_token_rec IS RECORD (

Â  Â  token VARCHAR2(4000),

Â  Â  start_pos PLS_INTEGER,

Â  Â  end_pos PLS_INTEGER

Â  );

Â  TYPE t_token_tab IS TABLE OF t_token_rec INDEX BY PLS_INTEGER;

Â  v_tokens t_token_tab;

Â  v_token_count PLS_INTEGER := 0;



Â  TYPE t_token_tab_nt IS TABLE OF VARCHAR2(100) INDEX BY PLS_INTEGER;

Â  v_unmatched_tokens t_token_tab;

Â  v_unmatched_count PLS_INTEGER := 0;



Â  -- To mark tokens consumed by multi-word operators

Â  TYPE t_bool_tab IS TABLE OF BOOLEAN INDEX BY PLS_INTEGER;

Â  v_token_consumed t_bool_tab;



Â  v_mode CHAR := UPPER(p_mode);



Â  -- Trim and uppercase token helper

Â  FUNCTION normalize_token(p_token VARCHAR2) RETURN VARCHAR2 IS

Â  BEGIN

Â  Â  RETURN UPPER(TRIM(p_token));

Â  END;



Â  -- Strip function parameters, e.g. "ROUND (n,d)" -> "ROUND"

Â  FUNCTION normalize_func_name(p_func VARCHAR2) RETURN VARCHAR2 IS

Â  BEGIN

Â  Â  RETURN REGEXP_REPLACE(UPPER(TRIM(p_func)), '\s*\(.*\)$');

Â  END;



Â  -- Checks if token is numeric

Â  FUNCTION is_number(p_token VARCHAR2) RETURN BOOLEAN IS

Â  BEGIN

Â  Â  RETURN REGEXP_LIKE(p_token, '^[+-]?(\d+(\.\d*)?|\.\d+)([Ee][+-]?\d+)?$');

Â  END;



Â  -- Check presence in list

Â  FUNCTION is_in_list(p_token VARCHAR2, p_list t_str_list, cnt NUMBER) RETURN BOOLEAN IS

Â  BEGIN

Â  Â  FOR i IN 1..cnt LOOP

Â  Â  Â  IF p_list(i) = p_token THEN

Â  Â  Â  Â  RETURN TRUE;

Â  Â  Â  END IF;

Â  Â  END LOOP;

Â  Â  RETURN FALSE;

Â  END;



Â  -- Check if token valid: attribute, operator, function, number, parentheses

Â  FUNCTION is_token_valid(p_token VARCHAR2) RETURN BOOLEAN IS

Â  Â  l_token VARCHAR2(100) := p_token;

Â  BEGIN

Â  Â  -- Parentheses always valid tokens

Â  Â  IF l_token IN ('(', ')') THEN

Â  Â  Â  RETURN TRUE;

Â  Â  END IF;



Â  Â  -- Strip trailing '(' from function calls

Â  Â  IF SUBSTR(l_token, -1) = '(' THEN

Â  Â  Â  l_token := SUBSTR(l_token, 1, LENGTH(l_token) - 1);

Â  Â  END IF;



Â  Â  -- Check if number

Â  Â  IF is_number(l_token) THEN

Â  Â  Â  RETURN TRUE;

Â  Â  END IF;



Â  Â  l_token := normalize_token(l_token);



Â  Â  IF is_in_list(l_token, v_attributes, v_attr_count) THEN

Â  Â  Â  RETURN TRUE;

Â  Â  ELSIF is_in_list(l_token, v_functions, v_func_count) THEN

Â  Â  Â  RETURN TRUE;

Â  Â  ELSIF is_in_list(l_token, v_operators, v_oper_count) THEN

Â  Â  Â  RETURN TRUE;

Â  Â  END IF;



Â  Â  RETURN FALSE;

Â  END;



Â  PROCEDURE load_functions(p_list OUT t_str_list, p_count OUT NUMBER) IS

Â  BEGIN

Â  Â  p_list.DELETE;

Â  Â  p_count := 0;

Â  Â  FOR r IN (

Â  Â  Â  SELECT return_value FROM apex_application_lov_entries

Â  Â  Â  WHERE list_of_values_name = 'UR EXPRESSION FUNCTIONS'

Â  Â  Â  ORDER BY return_value

Â  Â  ) LOOP

Â  Â  Â  p_count := p_count + 1;

Â  Â  Â  p_list(p_count) := normalize_func_name(r.return_value);

Â  Â  END LOOP;

Â  Â  IF p_count = 0 THEN

Â  Â  Â  RAISE_APPLICATION_ERROR(-20010, 'Functions LOV missing or empty');

Â  Â  END IF;

Â  END;



Â  PROCEDURE load_operators(p_list OUT t_str_list, p_count OUT NUMBER) IS

Â  BEGIN

Â  Â  p_list.DELETE;

Â  Â  p_count := 0;

Â  Â  FOR r IN (

Â  Â  Â  SELECT return_value FROM apex_application_lov_entries

Â  Â  Â  WHERE list_of_values_name = 'UR EXPRESSION OPERATORS'

Â  Â  Â  ORDER BY return_value

Â  Â  ) LOOP

Â  Â  Â  p_count := p_count + 1;

Â  Â  Â  p_list(p_count) := UPPER(TRIM(r.return_value));

Â  Â  END LOOP;

Â  Â  IF p_count = 0 THEN

Â  Â  Â  RAISE_APPLICATION_ERROR(-20011, 'Operators LOV missing or empty');

Â  Â  END IF;

Â  END;



Â  PROCEDURE load_attributes(p_hotel_id IN VARCHAR2, p_list OUT t_str_list, p_count OUT NUMBER) IS

Â  BEGIN

Â  Â  p_list.DELETE;

Â  Â  p_count := 0;

Â  Â  FOR r IN (

Â  Â  Â  SELECT key FROM ur_algo_attributes WHERE hotel_id = p_hotel_id

Â  Â  ) LOOP

Â  Â  Â  p_count := p_count + 1;

Â  Â  Â  p_list(p_count) := UPPER(TRIM(r.key));

Â  Â  END LOOP;

Â  Â  IF p_count = 0 THEN

Â  Â  Â  RAISE_APPLICATION_ERROR(-20012, 'Attributes missing for hotel_id ' || p_hotel_id);

Â  Â  END IF;

Â  END;



Â  -- Tokenizer splitting expression into tokens, tracking start/end pos

Â  PROCEDURE tokenize_expression(p_expr IN VARCHAR2, p_tokens OUT t_token_tab, p_count OUT NUMBER) IS

Â  Â  l_pos PLS_INTEGER := 1;

Â  Â  l_len PLS_INTEGER := LENGTH(p_expr);

Â  Â  l_token VARCHAR2(4000);

Â  Â  l_token_start PLS_INTEGER;

Â  Â  l_token_end PLS_INTEGER;

Â  BEGIN

Â  Â  p_tokens.DELETE;

Â  Â  p_count := 0;

Â  Â  WHILE l_pos <= l_len LOOP

Â  Â  Â  l_token := REGEXP_SUBSTR(p_expr,

Â  Â  Â  Â  '([A-Za-z0-9_\.]+|\d+(\.\d+)?|\(|\)|\S)',

Â  Â  Â  Â  l_pos,

Â  Â  Â  Â  1,

Â  Â  Â  Â  'i');

Â  Â  Â  EXIT WHEN l_token IS NULL;

Â  Â  Â  l_token_start := INSTR(p_expr, l_token, l_pos);

Â  Â  Â  l_token_end := l_token_start + LENGTH(l_token) - 1;

Â  Â  Â  p_count := p_count + 1;

Â  Â  Â  p_tokens(p_count) := t_token_rec(token => l_token, start_pos => l_token_start, end_pos => l_token_end);

Â  Â  Â  l_pos := l_token_end + 1;

Â  Â  Â  WHILE l_pos <= l_len AND SUBSTR(p_expr, l_pos, 1) = ' ' LOOP

Â  Â  Â  Â  l_pos := l_pos + 1;

Â  Â  Â  END LOOP;

Â  Â  END LOOP;

Â  END;



Â  FUNCTION build_json_errors(p_unmatched t_token_tab, p_count PLS_INTEGER) RETURN VARCHAR2 IS

Â  Â  v_json VARCHAR2(4000) := '[';

Â  BEGIN

Â  Â  IF p_count = 0 THEN

Â  Â  Â  RETURN '[]';

Â  Â  END IF;

Â  Â  FOR i IN 1..p_count LOOP

Â  Â  Â  v_json := v_json || '{"token":"' || p_unmatched(i).token ||

Â  Â  Â  Â  Â  Â  Â  Â  '","start":' || p_unmatched(i).start_pos ||

Â  Â  Â  Â  Â  Â  Â  Â  ',"end":' || p_unmatched(i).end_pos || '}';

Â  Â  Â  IF i < p_count THEN

Â  Â  Â  Â  v_json := v_json || ',';

Â  Â  Â  END IF;

Â  Â  END LOOP;

Â  Â  v_json := v_json || ']';

Â  Â  RETURN v_json;

Â  END;



Â  -- Return number of consecutive tokens matched as an operator starting at start_idx

Â  FUNCTION get_longest_operator_match(start_idx IN PLS_INTEGER) RETURN PLS_INTEGER IS

Â  Â  combined VARCHAR2(4000);

Â  Â  max_words CONSTANT PLS_INTEGER := 4; -- max operator words count

Â  Â  words_count PLS_INTEGER;

Â  Â  l_len PLS_INTEGER := LEAST(max_words, v_token_count - start_idx + 1);

Â  Â  i PLS_INTEGER;

Â  BEGIN

Â  Â  FOR words_count IN REVERSE 1 .. l_len LOOP

Â  Â  Â  combined := '';

Â  Â  Â  FOR i IN start_idx .. start_idx + words_count - 1 LOOP

Â  Â  Â  Â  IF combined IS NULL OR combined = '' THEN

Â  Â  Â  Â  Â  combined := UPPER(TRIM(v_tokens(i).token));

Â  Â  Â  Â  ELSE

Â  Â  Â  Â  Â  combined := combined || ' ' || UPPER(TRIM(v_tokens(i).token));

Â  Â  Â  Â  END IF;

Â  Â  Â  END LOOP;

Â  Â  Â  IF is_in_list(combined, v_operators, v_oper_count) THEN

Â  Â  Â  Â  RETURN words_count;

Â  Â  Â  END IF;

Â  Â  END LOOP;

Â  Â  RETURN 0;

Â  END;



BEGIN

Â  p_status := 'E';

Â  p_message := NULL;



Â  IF v_mode NOT IN ('V', 'C') THEN

Â  Â  p_status := 'E';

Â  Â  p_message := 'Invalid mode "' || p_mode || '". Valid are V or C.';

Â  Â  RETURN;

Â  END IF;



Â  IF p_hotel_id IS NULL THEN

Â  Â  p_status := 'E';

Â  Â  p_message := 'hotel_id is mandatory';

Â  Â  RETURN;

Â  END IF;



Â  IF p_expression IS NULL OR LENGTH(TRIM(p_expression)) = 0 THEN

Â  Â  p_status := 'E';

Â  Â  p_message := 'Expression is empty';

Â  Â  RETURN;

Â  END IF;



Â  load_functions(v_functions, v_func_count);

Â  load_operators(v_operators, v_oper_count);

Â  load_attributes(p_hotel_id, v_attributes, v_attr_count);



Â  tokenize_expression(p_expression, v_tokens, v_token_count);



Â  -- Initialize consumed array

Â  v_token_consumed.DELETE;



Â  DECLARE

Â  Â  i PLS_INTEGER := 1;

Â  Â  words_matched PLS_INTEGER := 0;

Â  BEGIN

Â  Â  WHILE i <= v_token_count LOOP

Â  Â  Â  words_matched := get_longest_operator_match(i);

Â  Â  Â  IF words_matched > 0 THEN

Â  Â  Â  Â  FOR j IN i .. i + words_matched - 1 LOOP

Â  Â  Â  Â  Â  v_token_consumed(j) := TRUE;

Â  Â  Â  Â  END LOOP;

Â  Â  Â  Â  i := i + words_matched;

Â  Â  Â  ELSE

Â  Â  Â  Â  -- Single token valid check

Â  Â  Â  Â  v_token_consumed(i) := is_token_valid(normalize_token(v_tokens(i).token));

Â  Â  Â  Â  i := i + 1;

Â  Â  Â  END IF;

Â  Â  END LOOP;

Â  END;



Â  IF v_mode = 'V' THEN

Â  Â  v_unmatched_tokens.DELETE;

Â  Â  v_unmatched_count := 0;

Â  Â  FOR i IN 1 .. v_token_count LOOP

Â  Â  Â  IF v_token_consumed.EXISTS(i) AND v_token_consumed(i) = FALSE THEN

Â  Â  Â  Â  v_unmatched_count := v_unmatched_count + 1;

Â  Â  Â  Â  v_unmatched_tokens(v_unmatched_count) := v_tokens(i);

Â  Â  Â  END IF;

Â  Â  END LOOP;



Â  Â  IF v_unmatched_count > 0 THEN

Â  Â  Â  p_status := 'E';

Â  Â  Â  p_message := 'Invalid tokens: ' || build_json_errors(v_unmatched_tokens, v_unmatched_count);

Â  Â  ELSE

Â  Â  Â  p_status := 'S';

Â  Â  Â  p_message := 'Expression validated successfully.';

Â  Â  END IF;



Â  ELSIF v_mode = 'C' THEN

Â  Â  p_status := 'S';

Â  Â  p_message := '';

Â  Â  FOR i IN 1..v_token_count LOOP

Â  Â  Â  IF v_token_consumed.EXISTS(i) AND v_token_consumed(i) = TRUE THEN

Â  Â  Â  Â  p_message := p_message || v_tokens(i).token || ' ';

Â  Â  Â  END IF;

Â  Â  END LOOP;

Â  Â  p_message := RTRIM(p_message);

Â  END IF;



EXCEPTION

Â  WHEN OTHERS THEN

Â  Â  p_status := 'E';

Â  Â  p_message := 'Failure: ' || SQLERRM;

END validate_expression;





END ur_utils;

/
